<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technical-Debt on BonnyCode</title>
    <link>http://localhost:1314/tags/technical-debt/</link>
    <description>Recent content in Technical-Debt on BonnyCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 25 Aug 2013 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1314/tags/technical-debt/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cost benefit analysis for bear lovers</title>
      <link>http://localhost:1314/posts/cost-benefit-analysis/</link>
      <pubDate>Sun, 25 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1314/posts/cost-benefit-analysis/</guid>
      <description>&lt;p&gt;Feature estimates are often blindly used for cost benefit analysis. This was no more apparent than when I once worked with a product manager named Bethany. She was responsible for what, in hindsight, was always a doomed social network for lovers of the North American Brown Bear. Bethany would routinely ask her developers to provide implementation costs for a long list of features. The developers would grumble and complain they need more detailed requirements before they can put together detailed estimates (because they had been burned in the past on being held to commitments based on changing scope). Bethany retorts that she just needs “T-shirt sizes”, which is code for wild ass guesses, so she can do cost benefit analysis. Logically, this makes sense. Like any savvy businesswoman, the product manager wants to get a return on her investment. You wouldn&amp;rsquo;t buy a piano without first knowing the price, right?&lt;/p&gt;
&lt;p&gt;The developer would always eventually relent and give her the feature estimates she asked for. The feature to let people upload pictures of their favorite bear for example would take 2 weeks to build. The feature to translate English into Bearease was estimated to take between 1 month and 2 years. The bear picture upload feature was a clear customer win and a frequent ask from the sites three customers, but the English to Bearease language translation was a real opportunity to differentiate their site from the other bear lover social networks. If the bearease translation feature cost only 1 month it made more sense to prioritize that feature, but not if it took 2 years.&lt;/p&gt;
&lt;p&gt;Bethany went back to the developers and asked why there was such a wide estimate in the translation feature and if there was a way to bring it down to the 1 month side. The developers came back with a bunch of mumbo jumbo about corpuses and having to maintain the translator by hand. They could develop a version of the feature in 1 month, but they wanted to do something fancier. Bethany heard that it could be done in 1 month if they really wanted to and said “go forth and develop my Bearease translator.” (she literally said that, it was weird then and it is weird now)&lt;/p&gt;
&lt;p&gt;A month later, as expected, the developers had cranked out a Bearease translator just like they said they would. Bethany and the developers had a big launch party, people drank a bit too much and they talked about all the money they were going to make when the site went IPO.&lt;/p&gt;
&lt;p&gt;Horribly hungover (likely due to the preponderance of blended whisky drinks), Bethany then tasked the developers to start working on the bear picture upload feature she had put off earlier. The developers went to work and two weeks later Bethany came back to check in on their launch. The developers said they were still working on it, and it would take them another two weeks. Bethany was furious. The feature was only supposed to take 2 weeks, she demanded to know why they couldn&amp;rsquo;t make their commitment. The developers started venting about how they were spending half their time maintaining the Bearease translator, constantly adding new words to the dictionary as users tried to translate words that they didn&amp;rsquo;t already have translations for. Bethany was angry at the developers for not being able to develop new features quickly enough and the developers were similarly angry they were spending so much of their time maintaining dictionaries rather than coding new features. They spent so much time being angry with each other that they stopped developing features all together. Facebook swooped in and stole their Bear loving user-base (with the ability to upload &lt;a href=&#34;http://upload.wikimedia.org/wikipedia/commons/6/6e/Bearclaw2.jpg&#34; title=&#34;Bear manicure&#34;&gt;bear pictures&lt;/a&gt; even!), and the rest is history.&lt;/p&gt;
&lt;p&gt;Bethany and the developers took away opposite lessons from the whole experience. Bethany said working with developers is lame because they are lazy and don&amp;rsquo;t understand business. She started her own hedge fund and now has a net worth measured in billions of dollars. The lesson the developers pulled from the experience was to never again do a feature quick and dirty, and the next time a product manager asks them to build a Bearease translator, they will say it takes 2 years, end of story.&lt;/p&gt;
&lt;p&gt;While Bethany can now afford to send several teams of highly trained ninja assassins my way for saying this, I put forth the contention that both Bethany and the developers pulled away the wrong lesson. Bethany&amp;rsquo;s real mistake was equating implementation cost with the true cost of a feature for cost benefit analysis. Software features, like most business investments, have operating costs associated with them. Those operating costs can vary wildly and there is frequently a trade off between initial investment cost and operating cost. If Bethany had taken into account the full cost of the features, she may have decided that uploading bear pictures was actually the wiser investment (something Facebook was smart enough to pick up on). Or at least she would have come in with the right expectation on what she was getting with her initial Bearease translator, and budgeted for followup work to make the feature more operationally maintainable if it was a success.&lt;/p&gt;
&lt;p&gt;The developers on the other hand learned too simplistic a lesson on technical debt. Technical debt, like any form of debt, is not evil. Without the ability to go into debt (i.e., taking out a loan), most new businesses couldn&amp;rsquo;t even get off the ground in the first place. If the demand for a Bearease translator was uncertain or if the immediate rush to market of being the first to have a Bearease translator justified it, the one month implementation with high technical debt could absolutely be the correct decision. For example, if they launched the Bearease translator and it completely tanked, they at least would have only lost out on 1 month of work rather than 2 years worth of work. Requirements and customer adoption are so subtly variable and changing in software development that this is often in fact the best approach to take. As long as ongoing operational cost is measured and time is continuously budgeted to reduce it, everyone can benefit from such a rapid iteration methodology.&lt;/p&gt;
&lt;p&gt;This post is also available in spoken &lt;a href=&#34;http://localhost:1314/posts/rawr/&#34;&gt;Bearease&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Banned: Implementation Inheritance</title>
      <link>http://localhost:1314/posts/banned-implementation-inheritance/</link>
      <pubDate>Sun, 07 Sep 2008 13:21:40 +0000</pubDate>
      
      <guid>http://localhost:1314/posts/banned-implementation-inheritance/</guid>
      <description>&lt;p&gt;Most software developers are aware of the principle &amp;ldquo;favor object composition over class inheritance&amp;rdquo;. I&amp;rsquo;ve written before about &lt;a href=&#34;http://localhost:1314/posts/tactical-polymo/&#34;&gt;tactical polymorphism&lt;/a&gt;, and if you reread the example all I was really doing was following this principle. I substituted an implementation that used implementation inheritance for one that used composition plus interface inheritance.&lt;/p&gt;
&lt;p&gt;I still see people that are aware of all the above and yet they still persist in creating designs centered around implementation inheritance. Horribly complicated designs that are a pain in the ass to code review. In the wall paper example I gave things aren&amp;rsquo;t yet so bad. Because implementation inheritance destroys modularity and tightly couples a whole swath of code, they organically grow into 5,000 line monstrosities, derived from another 8,000 line monstrosity. And because the classes are so complicated and so fragile, newcomers don&amp;rsquo;t dare refactor when making a small change or even always understand the correct place to put their change and thus the monstrosity continues to grow in odd and nonuniform ways. This sad disease is known as code rot although the scientific name for it is &lt;a href=&#34;http://en.wikipedia.org/wiki/Technical_debt&#34;&gt;technical debt&lt;/a&gt;. And while it has done wonders for certain aging C++ programmers job security, unless you wish to be maintaining the same lousy code 5 years from now because no one else can possibly understand it you should avoid it whenever possible.&lt;/p&gt;
&lt;p&gt;So what does this mean for you? Next time you try to do any implementation inheritance in your design, stop and say to yourself:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Am I possessed by some evil demon lord of bad design?&lt;/li&gt;
&lt;li&gt;Do I love this code so much that I want it to work on for the rest of my life and want no one else to ever understand it?&lt;/li&gt;
&lt;li&gt;Do I have a really really good reason why this limited use of implementation inheritance won&amp;rsquo;t end the universe as we know it?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you can&amp;rsquo;t answer yes to one of the above, please please &amp;ldquo;favor object composition over class inheritance&amp;rdquo;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
