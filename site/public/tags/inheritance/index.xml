<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Inheritance on BonnyCode</title>
    <link>https://www.bonnycode.com/tags/inheritance/</link>
    <description>Recent content in Inheritance on BonnyCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 07 Sep 2008 13:21:40 +0000</lastBuildDate><atom:link href="https://www.bonnycode.com/tags/inheritance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Banned: Implementation Inheritance</title>
      <link>https://www.bonnycode.com/posts/banned-implementation-inheritance/</link>
      <pubDate>Sun, 07 Sep 2008 13:21:40 +0000</pubDate>
      
      <guid>https://www.bonnycode.com/posts/banned-implementation-inheritance/</guid>
      <description>&lt;p&gt;Most software developers are aware of the principle &amp;ldquo;favor object composition over class inheritance&amp;rdquo;. I&amp;rsquo;ve written before about &lt;a href=&#34;https://www.bonnycode.com/posts/tactical-polymo/&#34;&gt;tactical polymorphism&lt;/a&gt;, and if you reread the example all I was really doing was following this principle. I substituted an implementation that used implementation inheritance for one that used composition plus interface inheritance.&lt;/p&gt;
&lt;p&gt;I still see people that are aware of all the above and yet they still persist in creating designs centered around implementation inheritance. Horribly complicated designs that are a pain in the ass to code review. In the wall paper example I gave things aren&amp;rsquo;t yet so bad. Because implementation inheritance destroys modularity and tightly couples a whole swath of code, they organically grow into 5,000 line monstrosities, derived from another 8,000 line monstrosity. And because the classes are so complicated and so fragile, newcomers don&amp;rsquo;t dare refactor when making a small change or even always understand the correct place to put their change and thus the monstrosity continues to grow in odd and nonuniform ways. This sad disease is known as code rot although the scientific name for it is &lt;a href=&#34;http://en.wikipedia.org/wiki/Technical_debt&#34;&gt;technical debt&lt;/a&gt;. And while it has done wonders for certain aging C++ programmers job security, unless you wish to be maintaining the same lousy code 5 years from now because no one else can possibly understand it you should avoid it whenever possible.&lt;/p&gt;
&lt;p&gt;So what does this mean for you? Next time you try to do any implementation inheritance in your design, stop and say to yourself:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Am I possessed by some evil demon lord of bad design?&lt;/li&gt;
&lt;li&gt;Do I love this code so much that I want it to work on for the rest of my life and want no one else to ever understand it?&lt;/li&gt;
&lt;li&gt;Do I have a really really good reason why this limited use of implementation inheritance won&amp;rsquo;t end the universe as we know it?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you can&amp;rsquo;t answer yes to one of the above, please please &amp;ldquo;favor object composition over class inheritance&amp;rdquo;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Continued Slander against the Noble If</title>
      <link>https://www.bonnycode.com/posts/continued-sland/</link>
      <pubDate>Sun, 16 Mar 2008 13:26:43 +0000</pubDate>
      
      <guid>https://www.bonnycode.com/posts/continued-sland/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve often said that &lt;strong&gt;if&lt;/strong&gt; statements are good indicators of poorly designed code. To illustrate my point, here is some code I recently stole from a major auto insurance firm&lt;a href=&#34;#disclaimer&#34;&gt;1&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;def&lt;/strong&gt; Money calculateAutoInsurance&lt;br&gt;
  &lt;strong&gt;if&lt;/strong&gt; (person &lt;strong&gt;is-a&lt;/strong&gt; Man)&lt;br&gt;
    Man man = (Man)person&lt;br&gt;
    &lt;strong&gt;if&lt;/strong&gt; (man.canGrowBeard)&lt;br&gt;
      &lt;strong&gt;return&lt;/strong&gt; $50&lt;br&gt;
    &lt;strong&gt;else&lt;/strong&gt;&lt;br&gt;
      &lt;strong&gt;return&lt;/strong&gt; $2000&lt;br&gt;
    &lt;strong&gt;end&lt;/strong&gt;&lt;br&gt;
  &lt;strong&gt;else if&lt;/strong&gt; (person &lt;strong&gt;is-a&lt;/strong&gt; Woman)&lt;br&gt;
    &lt;strong&gt;return&lt;/strong&gt; $10&lt;br&gt;
  &lt;strong&gt;else&lt;/strong&gt;&lt;br&gt;
    kaboom!&lt;br&gt;
  &lt;strong&gt;end&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;end&lt;/strong&gt;&lt;br&gt;
 &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;When casting or using any &lt;strong&gt;is-a&lt;/strong&gt; operator such as &lt;strong&gt;instanceof&lt;/strong&gt; in Java or &lt;strong&gt;kind_of?&lt;/strong&gt;/&lt;strong&gt;is_a?&lt;/strong&gt; in Ruby, you should stop to think about whether this is really the best solution. Sometimes it is necessary such as in Java when implementing the equals method or when hacking around a poorly designed third party library. If you are able to modify the classes you are calling though, a simpler solution is to push the conditional logic into the derived classes.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;http://en.wikipedia.org/wiki/Liskov_substitution_principle&#34;&gt;Liskov Substitution Principle&lt;/a&gt; and &lt;a href=&#34;http://en.wikipedia.org/wiki/Substitutability&#34;&gt;substitutability&lt;/a&gt; are helpful in understanding how to design proper polymorphic classes. When a caller is acting upon an interface, one should be able to substitute any type that implements that interface. In this case, the caller is breaking substitutability by casting to a specific derived type and basing logic on what the derived type is.&lt;/p&gt;
&lt;p&gt;Code that follows the substitutability principle is better for several reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Higher cohesion&lt;/strong&gt;&lt;/em&gt;. We can leave the polymorphic dispatch logic up to the language itself so that the calling code doesn&amp;rsquo;t have to worry about the specifics of manipulating derived types.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Better encapsulation&lt;/strong&gt;&lt;/em&gt;. If canGrowBeard was only exposed for auto insurance calculations, it can be rehidden when we push the auto insurance calculation into the derived Persons.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Safer/Easier to extend&lt;/strong&gt;&lt;/em&gt;. For example, it will be easier to add a &lt;a href=&#34;http://en.wikipedia.org/wiki/Third_gender&#34;&gt;third gender&lt;/a&gt; for Person if we know the caller always follows the substitutability principle. I would not advocate removing simplicity to add this extensibility, but given that it is simpler, the extra extensibility is a nice bonus.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; Man &lt;strong&gt;extends&lt;/strong&gt; Person&lt;br&gt;
&amp;hellip;&lt;br&gt;
  &lt;strong&gt;def&lt;/strong&gt; Money autoInsurance&lt;br&gt;
    &lt;strong&gt;if&lt;/strong&gt; (canGrowBeard)&lt;br&gt;
      &lt;strong&gt;return&lt;/strong&gt; $50&lt;br&gt;
    &lt;strong&gt;else&lt;/strong&gt;&lt;br&gt;
      &lt;strong&gt;return&lt;/strong&gt; $2000&lt;br&gt;
    &lt;strong&gt;end&lt;/strong&gt;&lt;br&gt;
  &lt;strong&gt;end&lt;/strong&gt;&lt;br&gt;
&amp;hellip;&lt;br&gt;
&lt;strong&gt;end&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class&lt;/strong&gt; Woman &lt;strong&gt;extends&lt;/strong&gt; Person&lt;br&gt;
&amp;hellip;&lt;br&gt;
  &lt;strong&gt;def&lt;/strong&gt; Money autoInsurance&lt;br&gt;
    &lt;strong&gt;return&lt;/strong&gt; $10&lt;br&gt;
  &lt;strong&gt;end&lt;/strong&gt;&lt;br&gt;
&amp;hellip;&lt;br&gt;
&lt;strong&gt;end&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;BONUS POINTS&lt;/strong&gt; for anyone that can tell me what is still highly suspicious about the design for the final solution.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Any illegal activity presented here is fictional and any resemblance to illegal activity past, present, or fictional is purely and completely coincidental.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
