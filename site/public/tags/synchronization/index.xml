<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Synchronization on BonnyCode</title>
    <link>http://localhost:1314/tags/synchronization/</link>
    <description>Recent content in Synchronization on BonnyCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 10 Jun 2008 00:39:10 +0000</lastBuildDate><atom:link href="http://localhost:1314/tags/synchronization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Synchronized Performance</title>
      <link>http://localhost:1314/posts/synchronized-performance/</link>
      <pubDate>Tue, 10 Jun 2008 00:39:10 +0000</pubDate>
      
      <guid>http://localhost:1314/posts/synchronized-performance/</guid>
      <description>&lt;p&gt;In a recent code review meeting, the performance of synchronized vs. non-synchronized methods came up. I threw out a ridiculous (in retrospect) statement that uncontested synchronized methods can have an overhead of up to 100 times that of an unsynchronized method. Kyle Haughey almost immediately called bullshit on my statement. I made some sample programs to try to test out the performance in some trivial cases and showed the respective output.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;class SynchronizedTest {&lt;br&gt;
    static public void main(String[] args) {&lt;br&gt;
        long startTime = System.currentTimeMillis();&lt;br&gt;
        StringBuilder sb = new StringBuilder();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            sb.append(foo());&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Synchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;/p&gt;
&lt;p&gt;        startTime = System.currentTimeMillis();&lt;br&gt;
        sb = new StringBuilder();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            sb.append(bar());&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Unsynchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static synchronized String foo() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static String bar() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;
Synchronized: 106&lt;br&gt;
Unsynchronized: 46&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I ran this test several times and it was very consistent in the numbers. Then I switched the order of the synchronized and the unsynchronized method to see if the order mattered at all.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;class SynchronizedTest {&lt;br&gt;
    static public void main(String[] args) {&lt;br&gt;
        long startTime = System.currentTimeMillis();&lt;br&gt;
        StringBuilder sb = new StringBuilder();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            sb.append(bar());&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Unsynchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;/p&gt;
&lt;p&gt;        startTime = System.currentTimeMillis();&lt;br&gt;
        sb = new StringBuilder();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            sb.append(foo());&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Synchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static synchronized String foo() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static String bar() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;
Unsynchronized: 72&lt;br&gt;
Synchronized: 82&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Very interesting. Switching the order made them nearly identical in timing, although the synchronized is still a bit slower. Then I tried removing the whole string append business and broke both out into their own executables.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;class Unsynchronized {&lt;br&gt;
    static public void main(String[] args) {&lt;br&gt;
        long startTime = System.currentTimeMillis();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            foo();&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Unsynchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static String foo() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;class Synchronized {&lt;br&gt;
    static public void main(String[] args) {&lt;br&gt;
        long startTime = System.currentTimeMillis();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            foo();&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Synchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static synchronized String foo() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;
Unsynchronized: 3&lt;br&gt;
Synchronized: 36&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I tried running the method with synchronized or unsynchronized first and it made little difference in this case. I was amazed that the synchronized version was so much slower though, especially because Kyle had done a pretty good job of convincing me that synchronized shouldn&amp;rsquo;t be slower. Just to make sure there was nothing else going on with the java compiler, I opened up the bytecode for both Synchronized and Unsynchronized using javap -c. Here is the bytecode for Unsychronized:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Compiled from &amp;ldquo;Unsynchronized.java&amp;rdquo;&lt;br&gt;
class Unsynchronized extends java.lang.Object{&lt;br&gt;
Unsynchronized();&lt;br&gt;
  Code:&lt;br&gt;
   0:    aload_0&lt;br&gt;
   1:    invokespecial    #1; //Method java/lang/Object.&amp;quot;&lt;!-- raw HTML omitted --&gt;&amp;rdquo;:()V&lt;br&gt;
   4:    return&lt;/p&gt;
&lt;p&gt;public static void main(java.lang.String[]);&lt;br&gt;
  Code:&lt;br&gt;
   0:    invokestatic    #2; //Method java/lang/System.currentTimeMillis:()J&lt;br&gt;
   3:    lstore_1&lt;br&gt;
   4:    iconst_0&lt;br&gt;
   5:    istore_3&lt;br&gt;
   6:    iload_3&lt;br&gt;
   7:    ldc    #3; //int 1000000&lt;br&gt;
   9:    if_icmpge    22&lt;br&gt;
   12:    invokestatic    #4; //Method foo:()Ljava/lang/String;&lt;br&gt;
   15:    pop&lt;br&gt;
   16:    iinc    3, 1&lt;br&gt;
   19:    goto    6&lt;br&gt;
   22:    getstatic    #5; //Field java/lang/System.err:Ljava/io/PrintStream;&lt;br&gt;
   25:    new    #6; //class java/lang/StringBuilder&lt;br&gt;
   28:    dup&lt;br&gt;
   29:    invokespecial    #7; //Method java/lang/StringBuilder.&amp;quot;&lt;!-- raw HTML omitted --&gt;&amp;rdquo;:()V&lt;br&gt;
   32:    ldc    #8; //String Unsynchronized:&lt;br&gt;
   34:    invokevirtual    #9; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;br&gt;
   37:    invokestatic    #2; //Method java/lang/System.currentTimeMillis:()J&lt;br&gt;
   40:    lload_1&lt;br&gt;
   41:    lsub&lt;br&gt;
   42:    invokevirtual    #10; //Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder;&lt;br&gt;
   45:    invokevirtual    #11; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;&lt;br&gt;
   48:    invokevirtual    #12; //Method java/io/PrintStream.println:(Ljava/lang/String;)V&lt;br&gt;
   51:    return&lt;/p&gt;
&lt;p&gt;static java.lang.String foo();&lt;br&gt;
  Code:&lt;br&gt;
   0:    ldc    #13; //String Hi&lt;br&gt;
   2:    areturn&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The bytecode for synchronized is identical, except for the comments. This at least shows that there isn&amp;rsquo;t some weird optimization going on at the bytecode level that is making the unsynchronized version go faster.&lt;/p&gt;
&lt;p&gt;At any level, it is pretty clear that on my mac book pro, in trivial examples, an uncontested synchronized does not add a 100 times overhead to a method call. It is also clear that these numbers fluctuate signicantly, so it is very important to actually profile your own code in as real an environment as possible when making any optimizations.&lt;/p&gt;
&lt;p&gt;If you want a more clear cut optimization win, replace the StringBuilder append calls in SynchronizedTest with straight string concatention, i.e. s += foo() and try running the program.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
