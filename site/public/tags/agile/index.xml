<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Agile on BonnyCode</title>
    <link>http://localhost:1313/tags/agile/</link>
    <description>Recent content in Agile on BonnyCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 16 Mar 2014 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/agile/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to be a better software manager</title>
      <link>http://localhost:1313/posts/how-to-be-a-better-software-manager/</link>
      <pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/how-to-be-a-better-software-manager/</guid>
      <description>&lt;p&gt;&amp;ldquo;My dev team is failing, what software process should we use to be more successful?&amp;rdquo;
&amp;ldquo;My dev team keeps missing their deliverables, what task management software should I use so they hit their commitments?&amp;rdquo;
&amp;ldquo;I&amp;rsquo;m not a very fast runner, what shoes should I buy to make me faster?&amp;rdquo;
&amp;ldquo;I&amp;rsquo;m a horrible cook, what knife should I use to make a really tasty meal?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;I get asked variations on these questions several times a month. You&amp;rsquo;d think by now I&amp;rsquo;d be better at answering them. Sadly, I still get this flutter of panic when I hear these questions where I run through my head the best way to unwind the web of assumptions behind these questions. This is where I begin visibly grimacing and possibly sighing. I then start responding with something like &amp;ldquo;well…. it depends… hmm…&amp;rdquo; And then I feel guilty for dodging the question when clearly they just want a simple answer and why won&amp;rsquo;t I just tell them the secret?&lt;/p&gt;
&lt;p&gt;The problem is software process, task management software, shoes, and knives are just tools. Having horrible tools can lead you to fail, but having great tools doesn&amp;rsquo;t make you succeed. What most people don&amp;rsquo;t want to hear is that success has more to do with preparation, persistence and a lot of hard work. There is no secret. I have learned a few lessons over the years though, and what follows is what I consider to be important when leading a successful development team.&lt;/p&gt;
&lt;h2 id=&#34;1-build-a-good-team-dont-manage-a-bad-one&#34;&gt;1. Build a good team, don&amp;rsquo;t manage a bad one&lt;/h2&gt;
&lt;p&gt;You don&amp;rsquo;t manage a bad team to be good, you build a good team and it mostly ends up managing itself. People always tell me that the things I do only work because I have a good team. That is because at least 40% of my time is spent on strictly building the team. Recruiting, mentoring, coaching, training. These activities take time to come to fruition and hard work, so don&amp;rsquo;t expect immediate results. Your persistence will pay off though.&lt;/p&gt;
&lt;p&gt;One of the best ways to build your team is by giving them accountability so they can practice exercising good judgement. Too many managers hoard decision making, prioritization and return on investment analysis. For example, make someone on your team accountable for the operational excellence of your team. Work with them to establish metrics for their success, have them come up with and prioritize the activities that will improve operational excellence. Be their mentor or find them a good mentor so they are setup for success in their role, but don&amp;rsquo;t undermine their authority by overriding them. Do this with as much of your manager responsibilities as you possibly can and constantly give your team members more accountability as they grow. Keep doing it until you worry that you&amp;rsquo;ll have nothing left to do yourself.&lt;/p&gt;
&lt;h2 id=&#34;2-craft-a-long-medium-and-short-term-vision&#34;&gt;2. Craft a long, medium and short term vision&lt;/h2&gt;
&lt;p&gt;Craft a long, medium and short term vision by deeply understanding your customers. On each of these time horizons, members of the team should be able to answer the question &amp;ldquo;What value is my team providing?&amp;rdquo; and &amp;ldquo;What value should my team provide?&amp;rdquo; Ask yourself how your team can be even better. How could your team create even more value? Don&amp;rsquo;t just do this in a bubble but get out there and learn more about your customers. Read individual customer feedback and piece together patterns that allow your team to deliver even greater value. This isn&amp;rsquo;t a one time activity but a never ending journey of both refining your team&amp;rsquo;s vision and building relationships with your customers.&lt;/p&gt;
&lt;h2 id=&#34;3-understand-the-role-of-trust-in-creating-process&#34;&gt;3. Understand the role of trust in creating process&lt;/h2&gt;
&lt;p&gt;It is critical that you understand the role of trust in creating your process. 90% of the process development teams build up is due to a lack of trust, both within the team and between the team and others. Detailed specifications are asked for because the people asking for functionality don&amp;rsquo;t trust the developers to build the right thing. Commitments are asked for because people don&amp;rsquo;t trust the developers to work hard and on the right priorities. These process artifacts take time though that take away from the time the team could be spending on creating more value. Ask yourself, is it possible that by building more trust we can run a lighter process that spends more time on creating value? This question should be approached honestly because the answer isn&amp;rsquo;t always yes but frequently is.&lt;/p&gt;
&lt;h2 id=&#34;4-manage-complexity-through-iteration-not-planning&#34;&gt;4. Manage complexity through iteration, not planning&lt;/h2&gt;
&lt;p&gt;Most software is not simple and unambiguous. If you are have people using your software directly, it is almost guaranteed to be complex. Humans and their organizations are infallible generators of complexity. The more ambiguous or complex the problem the more aggressive you should be about iteration. Aggressive iteration means being unafraid of throwaway work for the sake of getting a feature out earlier. Aggressive iteration means actually getting the software used though, an unused feature is a feature you aren&amp;rsquo;t learning from. As a side benefit, iteration is a powerful way to generate trust with customers and management. A productive development team that is regularly demonstrating working, valuable functionality will be more appreciated and have more autonomy.&lt;/p&gt;
&lt;h2 id=&#34;5-establish-a-planning-horizon-that-matches-your-business&#34;&gt;5. Establish a planning horizon that matches your business&lt;/h2&gt;
&lt;p&gt;Establish a planning horizon for your team that matches your business. Fast iteration isn&amp;rsquo;t an excuse for short term thinking. In my experience too many managers sacrifice long term value chasing after short term results. You need to consider the long term ramifications of your decisions. What is considered long term should match the context of your business. If you are in a fast moving startup that is trying to be the first to market, you should probably optimize for something closer to a 3 month planning horizon than a 3 year horizon. The shorter the planning horizon, the more you can ignore trust issues, technical debt, operational inefficiency, etc. because none of those will matter unless you have a successful product. On the other hand, if you are in a more stable environment with a long planning horizon, a heavy investment in operational efficiency and building trust will pay dividends and be much more cost effective in the long run.&lt;/p&gt;
&lt;h2 id=&#34;6-help-your-team-understand-their-long-term-success&#34;&gt;6. Help your team understand their long term success&lt;/h2&gt;
&lt;p&gt;A team needs a way to understand their long term success. The mistake most people make is they focus first on what is measurable rather than what is important. This leads to ridiculous measures of value like lines of code, story points, estimated accuracy, etc. It can be hard to wrap your head around what success looks like though. Engage your team, your own managers and your customers with the same question. Eventually you&amp;rsquo;ll come to a true measure of your success. The benefit of having that measure goes beyond just knowing what success looks like though. It gives your team autonomy in how they accomplish that success. Without a valid measure of success, your team will be more subject to signing up for arbitrary project deliverables. With a measure of success though, you can commit yourself to that end result, but maintain the freedom along the way in the best way to accomplish it.&lt;/p&gt;
&lt;h2 id=&#34;7-have-fun-be-ethical-and-treat-people-with-respect&#34;&gt;7. Have fun, be ethical and treat people with respect&lt;/h2&gt;
&lt;p&gt;Have fun, be ethical and treat people with respect. Seriously. You have only one life to live and the only measure of a well lived life is to be a good person doing good things. Never sacrifice that for creating more business value or other worldly success. I once worked for a company with massive internal strife. We argued endlessly about minutiae that seemed important at the time, gossiped, disrespected and hated each other. Everyone thought everyone else was an idiot. Then one day in the middle of all this we got called into a conference room to be told that our entire division had been laid off. All of a sudden our petty disagreements all went out the window and I once again saw my former coworkers as people again. I&amp;rsquo;m not saying to be soft, if someone isn&amp;rsquo;t delivering on a team then that needs to be dealt with, but that is never an excuse for disrespect.&lt;/p&gt;
&lt;p&gt;And now you know what I&amp;rsquo;ve learned so far about how to lead successful software development teams.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Throwaway Code: A Love Story</title>
      <link>http://localhost:1313/posts/throwaway-code-a-love-story/</link>
      <pubDate>Sat, 28 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/throwaway-code-a-love-story/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Throwaway Code&lt;/strong&gt;&lt;br&gt;
THrōəwā kōd&lt;br&gt;
&lt;em&gt;noun&lt;/em&gt; - Code that is written to launch a feature early, but will later be deleted either due to a future feature or a new process.&lt;br&gt;
&lt;em&gt;The BonnyCode Dictionary of Software Terms&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Not every love story is the same. There is the classic story of love at first sight. The love that feels destined and obvious from the very first moment. Source control was that way for me. I didn&amp;rsquo;t always use source control (gasp!), but I never went back once I did.&lt;/p&gt;
&lt;p&gt;I didn&amp;rsquo;t always love throwaway code. I may have occasionally flirted with throwaway code&amp;rsquo;s prettier cousin, the prototype, but I wouldn&amp;rsquo;t be caught dead with throwaway code. Today though? Throwaway code is one of the most powerful tools for a software developer. If I was on a desert island, and I was for some reason forced to do software development on that island, and for some reason I was limited in what abstract concepts I could take with me to that desert island, I would take throwaway code. And I would take long, romantic, moonlit walks on that beautiful desert island beach with throwaway code.&lt;/p&gt;
&lt;p&gt;How did I go from hating throwaway code to being soul mates? Throwaway code is so important because it is what makes iterative software development possible. The reason throwaway code is unappreciated, even in this age of Agile development, is because people don&amp;rsquo;t understand what it means to develop iteratively. Scientists have classified 3 stages of iterative development:&lt;/p&gt;
&lt;h2 id=&#34;stage-1-pretending&#34;&gt;Stage 1: Pretending&lt;/h2&gt;
&lt;p&gt;When most teams first try scrum (aka Agile with training wheels), they take a surface level approach to the process. They pick some short iteration cycle, 1-week, 2-weeks or a month. Strangely, nobody ever picks 3-weeks. Anyways, they then run the same process they always did, they just associated the work with whatever iteration is in flight. For example, a sprint planning meeting will go something like this:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;What are you working on this sprint?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;We are first working on testing the new Bear Translator functionality developed in the last sprint. We are then finishing up coding on the Bear Imagine functionality that we started two sprints ago but got delayed.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;In the pretend stage of iterative development, iterations are treated more like time labels for when work occurred and a way of determining how often to have meetings to discuss what to work on. The work itself isn&amp;rsquo;t driven by the iterations though.&lt;/p&gt;
&lt;h2 id=&#34;stage-2-done-done&#34;&gt;Stage 2: Done Done&lt;/h2&gt;
&lt;p&gt;Teams advance from the pretending phase of iterative development to the done done phase. This phase is characterized by the following exchange occurring several times a sprint:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Is the Bear Translator done?&amp;rdquo;&lt;br&gt;
&amp;ldquo;Yes&amp;rdquo;&lt;br&gt;
&amp;ldquo;Is it done done?&amp;rdquo;&lt;br&gt;
&amp;ldquo;No&amp;rdquo;&lt;/p&gt;
&lt;p&gt;This makes up for the failings of the pretend stage by emphasizing that the goal is to finish work inside of the sprint boundaries. It enforces a good discipline on the team to finish features. There is a heavy emphasis in this stage on time-boxing. Unlike the previous stage, the time-boxed sprint becomes the main driver for how work is broken up and assigned.&lt;/p&gt;
&lt;h2 id=&#34;stage-3-customer-use&#34;&gt;Stage 3: Customer Use&lt;/h2&gt;
&lt;p&gt;The final stage of iterative development moves from the frame of reference away from time-boxes towards minimizing the time before a customer gets value from the software. A typical exchange follows:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;The Bear Translator feature is finished! Let&amp;rsquo;s party!&amp;rdquo;&lt;br&gt;
&amp;ldquo;That&amp;rsquo;s great, how many people have used it?&amp;rdquo;&lt;br&gt;
&amp;ldquo;Nobody, we don&amp;rsquo;t have a UI for interacting with it yet. We&amp;rsquo;ve only deployed the backend work.&amp;rdquo;&lt;br&gt;
&amp;ldquo;Party is over everyone, the feature isn&amp;rsquo;t actually finished.&amp;rdquo;&lt;br&gt;
&amp;lt;collective groan, people throwing red plastic cups at the developer for being lame&amp;gt;&lt;/p&gt;
&lt;p&gt;This stage emphasizes building the minimal customer-valuable feature and then iteratively building on that to provide more value. The training wheels are off at this point and the sprint time-boxes are no longer necessary. The discipline learned from progressing through Stage 2 is useful at this point though because the emphasis needs to remain on finishing features.&lt;/p&gt;
&lt;h2 id=&#34;the-secret-of-iterative-development&#34;&gt;The Secret of Iterative Development&lt;/h2&gt;
&lt;p&gt;Most software teams are stuck somewhere between stages 1 and 2 of iterative development. Throwaway code appears as waste in these first two stages. If total value of a feature is measured as a typical manufacturing formula (Total Value = Manufacturing Rate * Value of Good), then any code that is thrown away is a loss on the expected total value. The secret to iterative development comes down to one concept. And it has little to do with the time-value of money or economic order quantities.&lt;/p&gt;
&lt;p&gt;The reason why iterative development is important is because &lt;strong&gt;software requirements aren&amp;rsquo;t known until the software is used by customers.&lt;/strong&gt; I no longer say this phrase around experienced developers because it provokes an uncontrollable reaction to tell me war-stories about just how true it is. The period between software development and customer use is when software can go off track. The smaller you make the cycle between the two, the more likely you are developing the right thing. These constant checkpoints make sure you are pointed in the right direction.&lt;/p&gt;
&lt;p&gt;To get an intuitive sense of just how critical this is, you can try the following experiment at home. Get in your car (a bike will also work) and drive to a part of town you&amp;rsquo;ve been to before.&lt;/p&gt;
&lt;p&gt;First, to simulate non-iterative software development: while driving, close your eyes for 1 minute and open them for minute, then close them for a minute, etc. You&amp;rsquo;ll find that when your eyes were closed, you probably ran into a building, ran stop lights, endangered many lives including your own.&lt;/p&gt;
&lt;p&gt;Second, if you are still conscious, simulate iterative software development: while driving, close your eyes for 1 second, then open them for 1 second, etc. Despite your eyes being closed for the same amount of time as in the first example, you likely never ran off the road and, if you did hit someone, you probably meant to do it.&lt;/p&gt;
&lt;p&gt;This is the difference between iterative development and non-iterative development. You know that you are on track because you are getting constant feedback. And you are getting that feedback where it matters, from the people that will use your software. Iterative development is so critical to staying on track that I will write copious amount of throwaway code to make iterations short. The ironic thing is, the people that avoid throwaway code end up writing the most in the end. They just do it unintentionally because they write large amounts of code that never gets used because their feature was off-track from the beginning.&lt;/p&gt;
&lt;p&gt;I love writing throwaway code because it is this beautiful launch vehicle to get the code I want to last out there and used immediately. When I actively make the decision to write it, I know there is a good chance I&amp;rsquo;m on the right track.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Strictly Need to Know</title>
      <link>http://localhost:1313/posts/strictly-need-to-know/</link>
      <pubDate>Sun, 18 May 2008 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/strictly-need-to-know/</guid>
      <description>&lt;p&gt;One of the bedrock principles in software engineering is information hiding. The traditional idea behind information hiding is imagined in the context of a group of software developers. Each of these software developers is working on their module that will use and be used by the modules made by other software developers. Given that software development is messy, we want to be able to make changes/fixes/upgrades to our module even after our module is in use by other modules. A module developer thus applies the principle of information hiding to separate the more stable interface of their module from the less stable implementation details. Other modules can only see the interface and not the implementation details, which gives the module developer the freedom to change the implementation details after it has begun to be used by other module developers.&lt;/p&gt;
&lt;p&gt;If this was still 1972 then the discussion could end here and we could all go back to writing that payroll program on the company&amp;rsquo;s UNIVAC 1108 like these two developers.&lt;/p&gt;
&lt;p&gt;Today, in the year 2008, state of the art software development looks more like these two developers who are pair programming a new facebook app.&lt;/p&gt;
&lt;p&gt;One of the first things you should notice is that today&amp;rsquo;s developers smile a lot more than developers from the 70s. This is because programming in the 70s was boring and lonely. Everybody (not just software developers) was all secretive and into hoarding information. Government agencies had strict need to know policies which prevented information from being shared and real intelligence from being synthesized. It is no surprise that this environment spawned a software methodology like waterfall based on the premise of cleanly separated departments with well established hand off points and restricted communication.&lt;/p&gt;
&lt;h2 id=&#34;lessons-from-intelligence-failures&#34;&gt;Lessons from Intelligence Failures&lt;/h2&gt;
&lt;p&gt;The failings of this approach are evident across the board. The 9/11 Report offers a clear description of the problem:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In each of our examples, no one was firmly in charge of managing the case and able to draw relevant intelligence from anywhere in the government, assign responsibilities across the agencies (foreign or domestic), track progress, and quickly bring obstacles up to the level where they could be resolved. Responsibility and accountability were diffuse.&lt;/p&gt;
&lt;p&gt;The agencies cooperated, some of the time. But even such cooperation as there was is not the same thing as joint action. &lt;strong&gt;When agencies cooperate, one defines the problem and seeks help with it. When they act jointly, the problem and options for action are defined differently from the start. Individuals from different backgrounds come together in analyzing a case and planning how to manage it.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;p&gt;In the 9/11 story, for example, we sometimes see examples of information that could be accessed—like the undistributed NSA information that would have helped identify Nawaf al Hazmi in January 2000. But someone had to ask for it. In that case, no one did. Or, as in the episodes we describe in chapter 8, the information is distributed, but in a compartmented channel. Or the information is available, and someone does ask, but it cannot be shared. &lt;strong&gt;What all these stories have in common is a system that requires a demonstrated &amp;ldquo;need to know&amp;rdquo; before sharing. This approach assumes it is possible to know, in advance, who will need to use the information.&lt;/strong&gt; Such a system implicitly assumes that the risk of inadvertent disclosure outweighs the benefits of wider sharing. Those Cold War assumptions are no longer appropriate. The culture of agencies feeling they own the information they gathered at taxpayer expense must be replaced by a culture in which the agencies instead feel they have a duty to the information—to repay the taxpayers&amp;rsquo; investment by making that information available.&lt;/p&gt;
&lt;p&gt;Each intelligence agency has its own security practices, outgrowths of the Cold War. We certainly understand the reason for these practices. Counterintelligence concerns are still real, even if the old Soviet enemy has been replaced by other spies.&lt;/p&gt;
&lt;p&gt;But the security concerns need to be weighed against the costs. Current security requirements nurture overclassification and excessive compartmentation of information among agencies. Each agency&amp;rsquo;s incentive structure opposes sharing, with risks (criminal, civil, and internal administrative sanctions) but few rewards for sharing information. No one has to pay the long-term costs of overclassifying information, though these costs—even in literal financial terms—are substantial. There are no punishments for not sharing information. &lt;strong&gt;Agencies uphold a &amp;ldquo;need-to-know&amp;rdquo; culture of information protection rather than promoting a &amp;ldquo;need-to-share&amp;rdquo; culture of integration.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;ndash; The 9/11 Commission Report&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;from-need-to-know-to-need-to-share&#34;&gt;From Need-to-Know to Need-to-Share&lt;/h2&gt;
&lt;p&gt;Modern agile programming techniques no longer have us living in a world of solitary software developers building their solely owned modules. Instead code is collectively owned by the team and there is no longer an &amp;ldquo;other&amp;rdquo; on the team to hide information from. Change is not feared because anyone on the team can make changes anywhere in the code. Changes are made safe through constant communication, a strict adherence to simplicity and a profound emphasis on readability.&lt;/p&gt;
&lt;p&gt;In this way the principle of information hiding is replaced by the principle of readability, changing the software team from a &amp;ldquo;need-to-know&amp;rdquo; culture to a &amp;ldquo;need-to-share&amp;rdquo; culture. Encapsulation and separation of concerns are no longer important because of information hiding but only when they make programs more readable. If the US government is willing to acknowledge the failures of information hiding despite the very real threat of espionage from foreign governments, what reasoning do you still have for promoting information hiding to protect yourself from your coworker at the next desk?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
