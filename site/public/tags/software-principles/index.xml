<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Principles on BonnyCode</title>
    <link>http://localhost:1313/tags/software-principles/</link>
    <description>Recent content in Software Principles on BonnyCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 30 Nov 2008 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/software-principles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>In Defense of Duplicated Code</title>
      <link>http://localhost:1313/posts/in-defense-of-duplicated-code/</link>
      <pubDate>Sun, 30 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/in-defense-of-duplicated-code/</guid>
      <description>&lt;p&gt;One of the first principles you will hear from anyone hoping to impart software development wisdom on young disciples is DRY. Don&amp;rsquo;t Repeat Yourself. If software best practices all lived in a little nation, the Honourable Commonwealth of Softwaria, its king would be DRY. A good king he was too.&lt;/p&gt;
&lt;p&gt;Since ages long since past, DRY has helped to keep javascripters from copy and pasting themselves into another rathole. At first, King DRY used methods to remove duplicate code. Formatting integers to currency a bajillion different places? No problem make a method to do the formating. The code is better because it is more readable (formatAsCurrency) and if you ever need to change or extend the logic you can do so in one place. Huzzah!&lt;/p&gt;
&lt;p&gt;Over the years, DRY took on further battles for the people of Softwaria. In the Thirty Year War against Visual Basic programmers, DRY brought forth the mighty powers of composition. Now large segments of functionality and data, not just individual methods, could be transported and duplicated to be used anywhere. A method to format an integer into currency? How about a currency class instead that can not only format itself to a string but also do any other logic you want to on currency all bundled nicely in a little package. Besides removing duplicate code, composition also provided encapsulation, higher cohesion and lowered coupling (the bad kind not the good kind!).&lt;/p&gt;
&lt;h2 id=&#34;the-corruption-of-power&#34;&gt;The Corruption of Power&lt;/h2&gt;
&lt;p&gt;As Lord Action once said though, power tends to corrupt, and absolute power corrupts absolutely. For in his zealous fervor to ban any duplicate code or logic he was tempted into delving into powerful and dark arts. DRY called upon his most powerful sorcerers who gave him the power of implementation inheritance. Yes he did eke out yet more removal of duplicated code. But in the process he sacrificed most of the benefits that encapsulation had provided.&lt;/p&gt;
&lt;p&gt;Yet more dissidents were found in the kingdom of Softwaria though and DRY delved into yet darker arts to combat them. This time he tapped into the power of reflection. With this power he could make mountains move (even if they were declared private!). Giddy with power, the king annihilated the duplicated code. Yes he had to sacrifice readability, but it seemed a small price to pay to eliminate those treasonous and heretical duplicate code bastards.&lt;/p&gt;
&lt;h2 id=&#34;the-final-corruption&#34;&gt;The Final Corruption&lt;/h2&gt;
&lt;p&gt;Finally, in the dark recesses of the kingdom, DRY found the last remaining resistance movements of duplicated code. They didn&amp;rsquo;t bother people much, they were largely just simple workers tilling away at their small plot of program. By this time the good king had become fanatical though. ALL DUPLICATED CODE MUST DIE! He called on his sorcerers one final time and asked for the power to remove the remaining resistance. He offered anything in his kingdom just for this one final grant of power. And the sorcerers delivered for they offered the power of metaprogramming.&lt;/p&gt;
&lt;p&gt;Now the King was no longer bound by the traditional physics of the land, instead he could reshape it in whatever likeness he desired. In the land of Java the king created code generators that created wide areas of forbidden code, code never to be touched or even looked at. XML spread like a disease, soon used to store the most important program logic. In the land of Ruby, programs created other programs and whole new languages sprang forth from nowhere to solve the most trivial of problems. Ruby on Rails came riding high with instant magical scaffolds. And the last of the duplicated code died&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;the-kingdoms-end&#34;&gt;The Kingdom&amp;rsquo;s End&lt;/h2&gt;
&lt;p&gt;The king was satisfied with himself for he had finally fulfilled his ultimate goal. Old King DRY stepped out to view his wondrous kingdom and no longer recognized what he saw. It was incomprehensible. Nothing made sense anymore, nothing was predictable and nothing worked as it seemed. Nobody, not even King DRY who created this world, understood it anymore. The sorcerers laughed knowing the land was now ruled by magic and the good king wept.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Strictly Need to Know</title>
      <link>http://localhost:1313/posts/strictly-need-to-know/</link>
      <pubDate>Sun, 18 May 2008 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/strictly-need-to-know/</guid>
      <description>&lt;p&gt;One of the bedrock principles in software engineering is information hiding. The traditional idea behind information hiding is imagined in the context of a group of software developers. Each of these software developers is working on their module that will use and be used by the modules made by other software developers. Given that software development is messy, we want to be able to make changes/fixes/upgrades to our module even after our module is in use by other modules. A module developer thus applies the principle of information hiding to separate the more stable interface of their module from the less stable implementation details. Other modules can only see the interface and not the implementation details, which gives the module developer the freedom to change the implementation details after it has begun to be used by other module developers.&lt;/p&gt;
&lt;p&gt;If this was still 1972 then the discussion could end here and we could all go back to writing that payroll program on the company&amp;rsquo;s UNIVAC 1108 like these two developers.&lt;/p&gt;
&lt;p&gt;Today, in the year 2008, state of the art software development looks more like these two developers who are pair programming a new facebook app.&lt;/p&gt;
&lt;p&gt;One of the first things you should notice is that today&amp;rsquo;s developers smile a lot more than developers from the 70s. This is because programming in the 70s was boring and lonely. Everybody (not just software developers) was all secretive and into hoarding information. Government agencies had strict need to know policies which prevented information from being shared and real intelligence from being synthesized. It is no surprise that this environment spawned a software methodology like waterfall based on the premise of cleanly separated departments with well established hand off points and restricted communication.&lt;/p&gt;
&lt;h2 id=&#34;lessons-from-intelligence-failures&#34;&gt;Lessons from Intelligence Failures&lt;/h2&gt;
&lt;p&gt;The failings of this approach are evident across the board. The 9/11 Report offers a clear description of the problem:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In each of our examples, no one was firmly in charge of managing the case and able to draw relevant intelligence from anywhere in the government, assign responsibilities across the agencies (foreign or domestic), track progress, and quickly bring obstacles up to the level where they could be resolved. Responsibility and accountability were diffuse.&lt;/p&gt;
&lt;p&gt;The agencies cooperated, some of the time. But even such cooperation as there was is not the same thing as joint action. &lt;strong&gt;When agencies cooperate, one defines the problem and seeks help with it. When they act jointly, the problem and options for action are defined differently from the start. Individuals from different backgrounds come together in analyzing a case and planning how to manage it.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;p&gt;In the 9/11 story, for example, we sometimes see examples of information that could be accessed—like the undistributed NSA information that would have helped identify Nawaf al Hazmi in January 2000. But someone had to ask for it. In that case, no one did. Or, as in the episodes we describe in chapter 8, the information is distributed, but in a compartmented channel. Or the information is available, and someone does ask, but it cannot be shared. &lt;strong&gt;What all these stories have in common is a system that requires a demonstrated &amp;ldquo;need to know&amp;rdquo; before sharing. This approach assumes it is possible to know, in advance, who will need to use the information.&lt;/strong&gt; Such a system implicitly assumes that the risk of inadvertent disclosure outweighs the benefits of wider sharing. Those Cold War assumptions are no longer appropriate. The culture of agencies feeling they own the information they gathered at taxpayer expense must be replaced by a culture in which the agencies instead feel they have a duty to the information—to repay the taxpayers&amp;rsquo; investment by making that information available.&lt;/p&gt;
&lt;p&gt;Each intelligence agency has its own security practices, outgrowths of the Cold War. We certainly understand the reason for these practices. Counterintelligence concerns are still real, even if the old Soviet enemy has been replaced by other spies.&lt;/p&gt;
&lt;p&gt;But the security concerns need to be weighed against the costs. Current security requirements nurture overclassification and excessive compartmentation of information among agencies. Each agency&amp;rsquo;s incentive structure opposes sharing, with risks (criminal, civil, and internal administrative sanctions) but few rewards for sharing information. No one has to pay the long-term costs of overclassifying information, though these costs—even in literal financial terms—are substantial. There are no punishments for not sharing information. &lt;strong&gt;Agencies uphold a &amp;ldquo;need-to-know&amp;rdquo; culture of information protection rather than promoting a &amp;ldquo;need-to-share&amp;rdquo; culture of integration.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;ndash; The 9/11 Commission Report&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;from-need-to-know-to-need-to-share&#34;&gt;From Need-to-Know to Need-to-Share&lt;/h2&gt;
&lt;p&gt;Modern agile programming techniques no longer have us living in a world of solitary software developers building their solely owned modules. Instead code is collectively owned by the team and there is no longer an &amp;ldquo;other&amp;rdquo; on the team to hide information from. Change is not feared because anyone on the team can make changes anywhere in the code. Changes are made safe through constant communication, a strict adherence to simplicity and a profound emphasis on readability.&lt;/p&gt;
&lt;p&gt;In this way the principle of information hiding is replaced by the principle of readability, changing the software team from a &amp;ldquo;need-to-know&amp;rdquo; culture to a &amp;ldquo;need-to-share&amp;rdquo; culture. Encapsulation and separation of concerns are no longer important because of information hiding but only when they make programs more readable. If the US government is willing to acknowledge the failures of information hiding despite the very real threat of espionage from foreign governments, what reasoning do you still have for promoting information hiding to protect yourself from your coworker at the next desk?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
