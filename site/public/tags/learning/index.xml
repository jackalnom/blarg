<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Learning on BonnyCode</title>
    <link>http://localhost:1314/tags/learning/</link>
    <description>Recent content in Learning on BonnyCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 12 Oct 2008 13:03:39 +0000</lastBuildDate><atom:link href="http://localhost:1314/tags/learning/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Programology</title>
      <link>http://localhost:1314/posts/programology/</link>
      <pubDate>Sun, 12 Oct 2008 13:03:39 +0000</pubDate>
      
      <guid>http://localhost:1314/posts/programology/</guid>
      <description>&lt;p&gt;If I were to teach a course at the University level, I would teach programology. Not the study of programming, but the study of existing computer programs. In the entire course, we would only read source code. Not small snippets of algorithms, and not trivialized polished examples of code created just for class. I&amp;rsquo;m talking about the industrial gritty always evolving code that actually runs a good part of the industrialized world now. Just as in cultural anthropology you study tribes from New Guinea to understand the various ways in which human society has evolved, we would study old programs, new programs, large programs, and small programs. We would study programs developed under a variety of different paradigms.&lt;/p&gt;
&lt;p&gt;It would be a weeder class. Writing code is hard; reading code is harder. But that is the point, being able to take an existing code base and quickly conceptualize the architecture and its design elements is what separates the software developer who can make the trivial one line fix to a problem and the one who bolts on three hundred lines of monstrous code because they didn&amp;rsquo;t quite get it.&lt;/p&gt;
&lt;p&gt;It will also help us not repeat the same mistakes that the majority of software developers have made before us. Most new software developers start out writing spaghetti code, code without known structure, features organically tacked on and general anarchy. Most developers eventually learn from their mistake, but when given the chance to rewrite their original software they swing too far the other way. They create a huge over-designed Frankenstein creation that is fully table driven, has an intricate inheritance tree and incorporates god knows how many design patterns. If we are lucky, the developer spends enough time in the field to eventually learn from this mistake as well and finds a happy medium.&lt;/p&gt;
&lt;p&gt;Fred Brooks described this problem as the &lt;a href=&#34;http://en.wikipedia.org/wiki/Second-system_effect&#34;&gt;second system effect&lt;/a&gt; in his book the &lt;a href=&#34;http://en.wikipedia.org/wiki/The_Mythical_Man-Month&#34;&gt;Mythical Man-Month&lt;/a&gt;, published in 1975, before most software developers today were even born. Yet, the vast majority of software developers today still follow the same evolution because we don&amp;rsquo;t study source code and what factors led that source code to arise why it did. We are like building architects who have never actually studied the design of any other building  besides those we personally took part in creating. Or a writer of novels who has never read any novels besides his own. To progress as a field, we must study those who came before us.&lt;/p&gt;
&lt;p&gt;I probably will never teach this class, despite the desperate need for it. In the end though, I say to anyone that wishes to be a great software developer, the surest way is to write lots and lots of code, and to read even more.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related posts on education and learning:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1314/posts/the-syllabus/&#34;&gt;The Syllabus&lt;/a&gt; - Detailed curriculum for the programology course&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1314/posts/the-ambiguous-n/&#34;&gt;The Ambiguous Null&lt;/a&gt; - Teaching example about proper null handling&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The Ambiguous Null</title>
      <link>http://localhost:1314/posts/the-ambiguous-n/</link>
      <pubDate>Sun, 24 Feb 2008 22:50:54 +0000</pubDate>
      
      <guid>http://localhost:1314/posts/the-ambiguous-n/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;if (paintColor == null)&lt;br&gt;
  print &amp;ldquo;Room is wall papered.&amp;rdquo;&lt;br&gt;
else&lt;br&gt;
  print &amp;ldquo;Room is painted %s.&amp;rdquo;, paintColor&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;null represents a void reference, but programmers often want to overload it to have other meanings. In the above example, a null paintColor means that the room is wall papered. Overloading null like this has two problems:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The caller becomes responsible for the special null case, rather than encapsulating this logic in one place.&lt;/li&gt;
&lt;li&gt;The code is not self documenting and thus should require comments. In the above example, outside of the immediate context, another programmer might assume that a null paintColor means a wall with no paint or wall paper on it at all.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A better solution is to rename the object paintColor to something more representative such as wallDecoration and then encapsulate the logic inside the object being called:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;print wallDecoration.description&lt;/p&gt;&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>
