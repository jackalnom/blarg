<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on BonnyCode</title>
    <link>http://localhost:1313/tags/performance/</link>
    <description>Recent content in Performance on BonnyCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 22 Jun 2008 20:50:50 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A Depressing, All Too Common Tale of OO Programmer meets Database</title>
      <link>http://localhost:1313/posts/a-depressing-all-too-common-tale-of-oo-programmer-meets-database/</link>
      <pubDate>Sun, 22 Jun 2008 20:50:50 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/a-depressing-all-too-common-tale-of-oo-programmer-meets-database/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve just been hired for your first job as an astronomical programmer. You have a graduate degree from CalTech in computer science and you regularly check your horoscope so you feel imminently qualified. Your first assignment is to write a method to count all the red giants in the universe. They use an object relational mapping framework so that you can put all your object oriented design skills to work and not need to worry anything about databases which is awesome because you know nothing about databases.&lt;/p&gt;
&lt;p&gt;You feel well trained in the arts of test driven development so you start out by writing a little test:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;test_count_red_giants&lt;br&gt;
  DB.clear&lt;br&gt;
  assert 0 == count_red_giants&lt;br&gt;
  DB.add_red_giant&lt;br&gt;
  assert 1 == count_red_giants&lt;br&gt;
  DB.add_white_dwarf&lt;br&gt;
  assert 1 == count_red_giants&lt;br&gt;
end&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You run the test and it fails as it should because you haven&amp;rsquo;t written your method yet. Being a good citizen you then write your new method:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;int count_red_giants&lt;br&gt;
  number_of_red_giants = 0&lt;br&gt;
  stars = DB.get_all_stars&lt;br&gt;
  for each star in stars&lt;br&gt;
    if (star.type == red_giant)&lt;br&gt;
      number_of_red_giants += 1&lt;br&gt;
    end&lt;br&gt;
  end  return number_of_red_giants;&lt;br&gt;
end&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You run your test now and EUREKA, you have just completed your first assignment. Ticker tape parades arrive, statues erected and you take a week vacation on Catalina island sipping on midori sours secure in the fact that you are one sweet modern programmer.&lt;/p&gt;
&lt;p&gt;This is the life, except when you get an urgent call from your boss two days into your vacation. Your code is now live and it doesn&amp;rsquo;t work. Everytime they try to count the red giants it times out. A helicopter arrives to take you back to the office so you can get to debugging the problem.&lt;/p&gt;
&lt;p&gt;You run your unit test again just to make sure some foolio didn&amp;rsquo;t mess with your code while you were gone but nope it still passes. You connect a debugger to your program and start stepping through your method while it is running live. You reach the line DB.get_all_stars and it cheerfully tells you &amp;ldquo;Returning 70 Sextillion Results&amp;rdquo;. Oh crap.&lt;/p&gt;
&lt;p&gt;You look back over the DB object and find another method called DB.find_stars_by_type. Bingo. You change your method to be the new awesome:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;int count_red_giants&lt;br&gt;
  number_of_red_giants = 0&lt;br&gt;
  stars = DB.find_stars_by_type(red_giant)&lt;br&gt;
  for each star in stars&lt;br&gt;
    number_of_red_giants += 1&lt;br&gt;
  end&lt;/p&gt;
&lt;p&gt;  return number_of_red_giants&lt;br&gt;
end&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You run your unit test and it passes. You congratulate yourself on your job well done, tell your boss that you have saved the day and take the helicopter back to Catalina to resume drinking neon colored drinks from martini glasses.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*cue hula music*&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;While laying in your hammock, drinking a fuzzy naval you get another call from the boss. Your program still runs too slowly. Back to the office we go again.&lt;/p&gt;
&lt;p&gt;Now you are stuck. Your program is so optimized now. Why does it still run so slow? In shame you eventually instant message your cousin who runs a PHP/MySql site from his basement that allows him to track his extensive collection of Warez. When you finish explaining your problem, your cousin calls you a total &amp;ldquo;n00b&amp;rdquo; and explains that you can do the count directly in SQL. Disgruntled by the fact that you have to dirty yourself with breaking out of your object abstraction, you eventually concede and after reading some documentation arrive at the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;int count_red_giants&lt;br&gt;
  return DB.query(&amp;lsquo;select count(*) from stars where type = red_giant&amp;rsquo;)&lt;br&gt;
end&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You run the unit test and it passes. You feel like you are an amazing ninja hax0r like those engineers that wrote the &lt;a href=&#34;http://www-03.ibm.com/ibm/history/exhibits/space/space_gemini.html&#34;&gt;Gemini Computer Guidance&lt;/a&gt; system in the 1960s. You tell the boss about your amazing discovery, your groundbreaking fix for the problem and it is back to Catalina for you.&lt;/p&gt;
&lt;p&gt;Finally, vacation without have to worry about programming or databases. Just sipping on your Miami Beach Ice Tea pondering over whether Obama or Lincoln will be remembered as the better president 50 years from now. And then you get a call from the boss&amp;hellip; it still doesn&amp;rsquo;t work.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*sigh*&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>N&#43;1 Select</title>
      <link>http://localhost:1313/posts/n1-select/</link>
      <pubDate>Tue, 17 Jun 2008 21:42:16 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/n1-select/</guid>
      <description>&lt;p&gt;You can forget about the performance of synchronized vs. unsynchronized, when you write code hitting your database that looks like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;peeps = Database.findMyPeeps&lt;br&gt;
for (each peep in peeps)&lt;br&gt;
  address = Database.findAddressForPeep(peep)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is called an N+1 select, although honestly it is more like a 1 + N select. You first run a query to find what you are looking for, and then you proceed to iterate over those results to do N more queries for each row in your initial query. This is a all too common reason for slow applications because of the overhead of the frequent database queries. My example above is the obvious version of this, and if you use an &lt;a href=&#34;http://en.wikipedia.org/wiki/Object-relational_mapping&#34;&gt;Object Relational Mapping&lt;/a&gt; (ORM) such as &lt;a href=&#34;http://www.hibernate.org/hib_docs/v3/reference/en/html/&#34;&gt;Hibernate&lt;/a&gt; or &lt;a href=&#34;http://ar.rubyonrails.com/&#34;&gt;ActiveRecord&lt;/a&gt; there is a much more stealthy version of this anti-pattern:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;peeps = PeepDAO.findMyPeeps&lt;br&gt;
for (each peep in peeps)&lt;br&gt;
   address = peep.getAddress&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If Address is a table with a foreign key relationship to Peep, and the mapping is defined as a lazy load, then it will result in the same N + 1 Select problem. How do you solve this?&lt;/p&gt;
&lt;p&gt;If you said by changing the mapping to an eager load&amp;hellip; WRONG!! First, run the code and see the queries that your ORM is making. Get a representative set of data and time how long the section of code takes to run. Only once you have in this in place are you in a situation where you are capable of making smart optimization choices.&lt;/p&gt;
&lt;p&gt;The first solution is to change the mapping for Peep to eager fetch addresses. This might be the right solution, but make sure you understand everywhere that Peep is used first. Changing the mapping will change the behavior of Peep everywhere it is used. You might be creating a local optimization where you speed up your for loop in this case, but pull down unnecessary data in 80% of the rest of the program.&lt;/p&gt;
&lt;p&gt;The second solution is to write a custom query. In Hibernate you can use either &lt;a href=&#34;http://www.hibernate.org/hib_docs/reference/en/html/queryhql.html&#34;&gt;HQL&lt;/a&gt; or the &lt;a href=&#34;http://www.hibernate.org/hib_docs/reference/en/html/querycriteria.html&#34;&gt;Criteria API&lt;/a&gt;. Most of the time this is going to be the superior solution to your N+1 Select problem.&lt;/p&gt;
&lt;p&gt;Can anyone tell me in what situations they would use HQL vs. using the Criteria API?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Databases from the Battlefield</title>
      <link>http://localhost:1313/posts/databases-from-the-battlefield/</link>
      <pubDate>Sun, 15 Jun 2008 23:15:07 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/databases-from-the-battlefield/</guid>
      <description>&lt;p&gt;There is a ladder of knowledge in learning about databases. Step one is learning the basic commands SELECT, INSERT, UPDATE and DELETE. After that you learn about Subselects and the various JOINs. Eventually you learn about creating your own schema, many to many relationships and database indexes. Eventually you might even learn about &lt;a href=&#34;http://en.wikipedia.org/wiki/Database_normalization&#34;&gt;database normal forms&lt;/a&gt; which are similar to the Ten Commandments: people think they know what they are but when pressed can normally only name one or two (killing and stealing are bad right?).&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m going to assume you already know all of this or if you don&amp;rsquo;t that you can easily learn it on your own. At the very least you should learn the database normal forms so you can impress in a job interview some day.&lt;/p&gt;
&lt;p&gt;Instead, I&amp;rsquo;m going to teach you the zen secrets of databases that they don&amp;rsquo;t teach you in school. My next post will start with the infamous N+1 Select.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Synchronized Performance</title>
      <link>http://localhost:1313/posts/synchronized-performance/</link>
      <pubDate>Tue, 10 Jun 2008 00:39:10 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/synchronized-performance/</guid>
      <description>&lt;p&gt;In a recent code review meeting, the performance of synchronized vs. non-synchronized methods came up. I threw out a ridiculous (in retrospect) statement that uncontested synchronized methods can have an overhead of up to 100 times that of an unsynchronized method. Kyle Haughey almost immediately called bullshit on my statement. I made some sample programs to try to test out the performance in some trivial cases and showed the respective output.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;class SynchronizedTest {&lt;br&gt;
    static public void main(String[] args) {&lt;br&gt;
        long startTime = System.currentTimeMillis();&lt;br&gt;
        StringBuilder sb = new StringBuilder();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            sb.append(foo());&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Synchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;/p&gt;
&lt;p&gt;        startTime = System.currentTimeMillis();&lt;br&gt;
        sb = new StringBuilder();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            sb.append(bar());&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Unsynchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static synchronized String foo() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static String bar() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;
Synchronized: 106&lt;br&gt;
Unsynchronized: 46&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I ran this test several times and it was very consistent in the numbers. Then I switched the order of the synchronized and the unsynchronized method to see if the order mattered at all.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;class SynchronizedTest {&lt;br&gt;
    static public void main(String[] args) {&lt;br&gt;
        long startTime = System.currentTimeMillis();&lt;br&gt;
        StringBuilder sb = new StringBuilder();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            sb.append(bar());&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Unsynchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;/p&gt;
&lt;p&gt;        startTime = System.currentTimeMillis();&lt;br&gt;
        sb = new StringBuilder();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            sb.append(foo());&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Synchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static synchronized String foo() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static String bar() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;
Unsynchronized: 72&lt;br&gt;
Synchronized: 82&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Very interesting. Switching the order made them nearly identical in timing, although the synchronized is still a bit slower. Then I tried removing the whole string append business and broke both out into their own executables.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;class Unsynchronized {&lt;br&gt;
    static public void main(String[] args) {&lt;br&gt;
        long startTime = System.currentTimeMillis();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            foo();&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Unsynchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static String foo() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;class Synchronized {&lt;br&gt;
    static public void main(String[] args) {&lt;br&gt;
        long startTime = System.currentTimeMillis();&lt;br&gt;
        for (int i = 0; i &amp;lt; 1000000; i++) {&lt;br&gt;
            foo();&lt;br&gt;
        }&lt;br&gt;
        System.err.println(&amp;ldquo;Synchronized: &amp;quot; +&lt;br&gt;
                (System.currentTimeMillis() - startTime));&lt;br&gt;
    }&lt;/p&gt;
&lt;p&gt;    static synchronized String foo() {&lt;br&gt;
        return &amp;ldquo;Hi&amp;rdquo;;&lt;br&gt;
    }&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;
Unsynchronized: 3&lt;br&gt;
Synchronized: 36&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I tried running the method with synchronized or unsynchronized first and it made little difference in this case. I was amazed that the synchronized version was so much slower though, especially because Kyle had done a pretty good job of convincing me that synchronized shouldn&amp;rsquo;t be slower. Just to make sure there was nothing else going on with the java compiler, I opened up the bytecode for both Synchronized and Unsynchronized using javap -c. Here is the bytecode for Unsychronized:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Compiled from &amp;ldquo;Unsynchronized.java&amp;rdquo;&lt;br&gt;
class Unsynchronized extends java.lang.Object{&lt;br&gt;
Unsynchronized();&lt;br&gt;
  Code:&lt;br&gt;
   0:    aload_0&lt;br&gt;
   1:    invokespecial    #1; //Method java/lang/Object.&amp;quot;&lt;init&gt;&amp;rdquo;:()V&lt;br&gt;
   4:    return&lt;/p&gt;
&lt;p&gt;public static void main(java.lang.String[]);&lt;br&gt;
  Code:&lt;br&gt;
   0:    invokestatic    #2; //Method java/lang/System.currentTimeMillis:()J&lt;br&gt;
   3:    lstore_1&lt;br&gt;
   4:    iconst_0&lt;br&gt;
   5:    istore_3&lt;br&gt;
   6:    iload_3&lt;br&gt;
   7:    ldc    #3; //int 1000000&lt;br&gt;
   9:    if_icmpge    22&lt;br&gt;
   12:    invokestatic    #4; //Method foo:()Ljava/lang/String;&lt;br&gt;
   15:    pop&lt;br&gt;
   16:    iinc    3, 1&lt;br&gt;
   19:    goto    6&lt;br&gt;
   22:    getstatic    #5; //Field java/lang/System.err:Ljava/io/PrintStream;&lt;br&gt;
   25:    new    #6; //class java/lang/StringBuilder&lt;br&gt;
   28:    dup&lt;br&gt;
   29:    invokespecial    #7; //Method java/lang/StringBuilder.&amp;quot;&lt;init&gt;&amp;rdquo;:()V&lt;br&gt;
   32:    ldc    #8; //String Unsynchronized:&lt;br&gt;
   34:    invokevirtual    #9; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;br&gt;
   37:    invokestatic    #2; //Method java/lang/System.currentTimeMillis:()J&lt;br&gt;
   40:    lload_1&lt;br&gt;
   41:    lsub&lt;br&gt;
   42:    invokevirtual    #10; //Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder;&lt;br&gt;
   45:    invokevirtual    #11; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;&lt;br&gt;
   48:    invokevirtual    #12; //Method java/io/PrintStream.println:(Ljava/lang/String;)V&lt;br&gt;
   51:    return&lt;/p&gt;
&lt;p&gt;static java.lang.String foo();&lt;br&gt;
  Code:&lt;br&gt;
   0:    ldc    #13; //String Hi&lt;br&gt;
   2:    areturn&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The bytecode for synchronized is identical, except for the comments. This at least shows that there isn&amp;rsquo;t some weird optimization going on at the bytecode level that is making the unsynchronized version go faster.&lt;/p&gt;
&lt;p&gt;At any level, it is pretty clear that on my mac book pro, in trivial examples, an uncontested synchronized does not add a 100 times overhead to a method call. It is also clear that these numbers fluctuate signicantly, so it is very important to actually profile your own code in as real an environment as possible when making any optimizations.&lt;/p&gt;
&lt;p&gt;If you want a more clear cut optimization win, replace the StringBuilder append calls in SynchronizedTest with straight string concatention, i.e. s += foo() and try running the program.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
