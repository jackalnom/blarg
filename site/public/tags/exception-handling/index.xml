<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Exception-Handling on BonnyCode</title>
    <link>http://localhost:1313/tags/exception-handling/</link>
    <description>Recent content in Exception-Handling on BonnyCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 04 May 2008 22:07:32 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/exception-handling/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Catching Exceptions</title>
      <link>http://localhost:1313/posts/catching-except/</link>
      <pubDate>Sun, 04 May 2008 22:07:32 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/catching-except/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;“It’s 3 am and your children are safe and asleep.
But there’s a phone in the White House and it is ringing.
Something is happening in the world.
Your vote will decide who answers that call.
Whether it is someone who already knows the world’s leaders,
Knows the military,
Someone tested and ready to lead in a dangerous world.
It&amp;rsquo;s 3 am and your children are safe and asleep.
Who do you want answering that phone?”
&amp;ndash; voiceover for Hillary Clinton campaign ad&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;How will you respond when things don&amp;rsquo;t go accordingly to plan? We recognize true greatness not as those that do well when everything is fine, but those who respond with grace and courage when things go terribly wrong. Most historians consider our three greatest presidents to be George Washington, Abraham Lincoln, and Franklin Roosevelt. It is no coincidence that they led us through the 4 largest crises our nation has faced: the War for Independence, the Civil War, the Great Depression and World War II.&lt;/p&gt;
&lt;p&gt;I believe the absolutely most important thing about being a great professional software developer is being prepared for when things go wrong. The naive developer will claim that nothing can go wrong and so fails to prepare. The battle hardened but cynical developer throws up their hands and says there is nothing they can do about it. I will try to walk you somewhere between these two extremes and combine the pessimism that tells us what can go wrong and the optimism that tells us how we can recover from it.&lt;/p&gt;
&lt;p&gt;These are the error handling techniques that software developers should be aware of:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The hard fail.&lt;/strong&gt; This is the easiest and normally the least useful way to handle an error. Just kill your program when something goes wrong. I once worked with a programmer that handled every catch statement with:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;} catch(Exception) {
  System.exit(1);
}&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;As a user, this was a bizarre experience to say the least. You would select a menu option and it would suddenly and unexpectedly quit, losing all of your work and giving you no indication of what you actually did wrong. It is a good way to make your user base fearful, neurotic and afraid to color outside the lines though.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The hard fail with a heartbeat.&lt;/strong&gt; This is similar to the hard fail, but with a separate process whose sole job is to detect the death of your program and to restart it when it dies. This can actually be an amazingly simple and powerful way to handle errors for always up, non-user facing programs. It spares you from writing unnecessary and potentially buggy error recovery code. For highly fault tolerant programs, this approach is used across multiple machines with automatic failover when errors occur. Erlang is built with this style of error handling and was used to write the 1.7 million line &lt;a href=&#34;http://wadler.blogspot.com/2005/05/concurrency-oriented-programming-in.html&#34;&gt;AXD301&lt;/a&gt; which has a measured reliability of 99.9999999% (9 nines).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Keep on trying.&lt;/strong&gt; Sometimes persistence is all it takes. This type of error handling is useful in situations where it is reasonable to assume that you will eventually succeed. This is especially useful when building resilient applications that work across a network. Be careful to differentiate between errors that can reasonably expected to eventually work when retried. For example if you receive an HTTP 403 Forbidden error it makes no sense to continue to retry the request, an HTTP 503 Service Unavailable error on the other hand is a good candidate for a retry. As Albert Einstein warned &amp;ldquo;The definition of insanity is doing the same thing over and over again and expecting different results.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Lastly, be a good citizen and use an &lt;a href=&#34;http://en.wikipedia.org/wiki/Exponential_backoff&#34;&gt;exponential back off&lt;/a&gt; when retrying. The last thing that will help an overburdened server is to have all of its clients hitting it repeatedly every half second when they encounter an error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fix it and move on.&lt;/strong&gt; Some errors are just plain correctable. A good example is if a directory you are expecting doesn&amp;rsquo;t exist. If the directory is just going to be used to output some files, consider just creating the directory and then moving on.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tell me about all about it.&lt;/strong&gt; This is the style of error handling most often encountered by non-technical users. A ominous dialog box appears to slap the user across the face saying &amp;ldquo;Error Encountered 0xDEADBEEF I/O unknown Result Code 42&amp;rdquo;. There are several things commonly wrong with this style of error.&lt;/p&gt;
&lt;p&gt;The first is that programmers write non-understandable error messages. It is bad enough when programmers write error messages that only they understand, worse I see error messages that even the programmer who wrote the program doesn&amp;rsquo;t understand because it provides no context for what the error actually is. Don&amp;rsquo;t just say, &amp;ldquo;error encountered&amp;rdquo;, you need to tell the user why the error occurred and what they can do to correct it if it isn&amp;rsquo;t obvious.&lt;/p&gt;
&lt;p&gt;The second thing wrong with this type of error is that it is used in cases where the program is making the user do something manually that the program could have done automatically. If you need a temp directory created before you start, don&amp;rsquo;t tell the user and make them create it when the program could more easily create the directory itself and keep on working. If you encounter a network error, try auto-retrying with a cancel button, and don&amp;rsquo;t make the user sit there manually clicking retry.&lt;/p&gt;
&lt;p&gt;The third thing wrong with this type of error is that it can be a potential security hole. If you expose programmatic details in your error message such as a Java stack trace, this can be valuable information to those trying to hack your program. Sometimes you can be too helpful in your error message as well. If someone is prohibited from accessing a piece of information, telling them that it exists but that they can&amp;rsquo;t get it can be valuable to the would be hacker in itself. In this case, you might want to make forbidden return the same error as not found.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Phone home.&lt;/strong&gt; Too many programmers never anticipate what it will be like to debug a problem when the program is out in the wild and not sitting in debug mode on their own box. If you think it is hard reproducing problems on your machine, imagine what you will do when a user calls up and says &amp;ldquo;I hit the blue button on the right and then it told me &amp;lsquo;unexpected error&amp;rsquo;&amp;rdquo; when there is no blue button in your program and unexpected error is the error message you use for a gazillion different possible error cases. If possible, collect and even automatically send as much information as you can gather about errors back to yourself when an error occurs. There are numerous caveats to this such as being careful to not send sensitive information (credit card numbers, classified material, yadda yadda) and letting users know before sending the debug info if it is an externally distributed software. The lesson is the same though. When handling an error that indicates a bug in the program, collect the information you will need to reproduce and fix the bug back on your own machine.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rollback.&lt;/strong&gt; This type of error handling is useful normally in combination with one of the methods mentioned above. Its a travesty that most programmers only encounter rollbacks when dealing with database transactions. Being able to rollback the state of your program is an extremely useful concept when writing explorable user friendly applications. Your transactional rollback mechanism can be tied into an undo mechanism that allows your user to to undo undesirable behavior. This type of program would be the opposite of the fear driven program described in the &amp;lsquo;fail hard&amp;rsquo; error handling I first described. A word of caution though, writing rollback features is notoriously difficult. If at all humanly (computerly?) possible, it is far easier to snapshot the state and just revert back then to actually try to rewind an operation. This isn&amp;rsquo;t always possible but it should always be the first option you consider.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Exception handling isn&amp;rsquo;t a glamorous topic, but it is still important. Be the humble programmer that looks for ways to make their program cool and confident in the face of adversity and unexpected situations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related posts in this series:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/exceptional-pro/&#34;&gt;Exceptional Programming&lt;/a&gt; - Introduction to exception handling best practices&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/exceptions-vs-s/&#34;&gt;Exceptions vs. Status Codes vs. Assertions&lt;/a&gt; - Understanding the differences between error handling techniques&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/exceptions-are/&#34;&gt;Exceptions are part of the Method Signature&lt;/a&gt; - How exceptions form part of your method&amp;rsquo;s contract&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Exceptions are part of the Method Signature</title>
      <link>http://localhost:1313/posts/exceptions-are/</link>
      <pubDate>Sun, 20 Apr 2008 17:32:03 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/exceptions-are/</guid>
      <description>&lt;p&gt;The exceptions thrown by your method are part of the signature of your method. This is true technically of checked exceptions in Java, but more importantly it is true semantically. One of the poorest way to handle exceptions is to do either this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;def foo throws SomeRandomException, SomeOtherException, YetAnotherUselessException, ImNotDoneThrowingExceptions, ILetEclipseDesignMyMethodsException, TheUserWillNeverCareAboutThisException&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;OR this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;def bar throws Exception&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The foo method is called implementation driven exception throwing. It is most often seen when people let their IDE (such as Eclipse), design their method signatures for them by just throwing any old exception that comes along in implementation. If the implementation changes, one can assume that the exceptions will change.&lt;/p&gt;
&lt;p&gt;The bar method is called shit happens exception throwing. It tells other programmers that the designer of this method has no idea what could possibly go wrong so you better just be prepared to catch it all.&lt;/p&gt;
&lt;p&gt;Much preferred is to design the exceptions your method throws as part of the signature for the method. Not just what can go wrong, but what error cases do we want to differentiate from. When parsing an Integer, most users probably don&amp;rsquo;t care whether it failed because the string was null vs. the string containing non-digits vs. the string containing an integer that was bigger than max int. So the designers of the method just bundled it all up in a NumberFormatException. If there were a strong use case for differentiating between all other errors and the Integer being too large, then the method would instead throw NumberFormatException and IntegerOverflowException.&lt;/p&gt;
&lt;p&gt;I will follow up next week on how to properly catch exceptions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related posts in this series:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/exceptional-pro/&#34;&gt;Exceptional Programming&lt;/a&gt; - Introduction to exception handling best practices&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/exceptions-vs-s/&#34;&gt;Exceptions vs. Status Codes vs. Assertions&lt;/a&gt; - Understanding the differences between error handling techniques&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/catching-except/&#34;&gt;Catching Exceptions&lt;/a&gt; - Comprehensive guide to error handling techniques&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Exceptions vs. Status Codes vs. Assertions</title>
      <link>http://localhost:1313/posts/exceptions-vs-s/</link>
      <pubDate>Mon, 14 Apr 2008 19:57:57 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/exceptions-vs-s/</guid>
      <description>&lt;p&gt;Step one to handling exceptional code is to be aware of the common techniques, their semantic meaning and any pitfalls. The three common error handling techniques are exceptions, status codes and assertions. If your language has exceptions, exceptions should be used in any situation where there is a normal program flow and some input outside of your control can disrupt that flow. At some point in your life, and this may have already happened to you, an antediluvian C programmer is going to tell you about all the evils of exceptions and how God intended man to use status codes for all errors. Do not be deceived by this &lt;a href=&#34;http://www.joelonsoftware.com/items/2003/10/13.html&#34;&gt;siren&lt;/a&gt;) and her false promises.&lt;/p&gt;
&lt;p&gt;A status code should be used when your language lacks exceptions or when the normal program flow is to deal with the error case. For example, if you are writing a method to validate an address, it should return a message saying what is wrong with the address and not just throw an exception that needs to be immediately caught if there is a problem with the address.&lt;/p&gt;
&lt;p&gt;Lastly, an assertion should be used as a sanity check that your program is correct as written. You should expect to change your program&amp;rsquo;s code when an assertion is triggered. The one thing to watch out for in using assertions is that they can be turned off. When turned off, the code that is being asserted is not actually run. This means never put logic your program depends upon inside of an assert.&lt;/p&gt;
&lt;p&gt;Philosophically, the methodology I use with any of these error techniques is based on the beauty of a program driven by its linear proportions. I like code that looks like this:&lt;/p&gt;
&lt;p&gt;   expression1,&lt;br&gt;
   expression2,&lt;br&gt;
   expression3,&lt;br&gt;
   expression4,&lt;br&gt;
   &amp;hellip;&lt;/p&gt;
&lt;p&gt;instead of like this:&lt;/p&gt;
&lt;p&gt;   if (conditional)&lt;br&gt;
      expression1,&lt;br&gt;
   if (conditional2)&lt;br&gt;
      if (conditional3)&lt;br&gt;
         expression2,&lt;br&gt;
      else&lt;br&gt;
         expression3,&lt;br&gt;
   else if (conditional4)&lt;br&gt;
      expression4,&lt;/p&gt;
&lt;p&gt;I could consume an entire post (and I shall!) on all the reasons I prefer the linear rather than the jagged program. The way I use exceptions, status codes and assertions can be roughly guided by this preference though. Exceptions are good when they promote code that is linear. When you need to check the status code on every line, that destroys the linear nature of the program. Many programmers get around this by then defining Macros that use gotos, but at that point you are really just crafting your own exception handling. When I do end up preferring status codes to exceptions is when using a status code leads me closer to a linear program. This is true of the validate method I mentioned above, I still prefer calling code that looks like this:&lt;/p&gt;
&lt;p&gt;   expression1,&lt;br&gt;
   if (foo.isValid())&lt;br&gt;
      expression2,&lt;br&gt;
      expression3&lt;br&gt;
   else&lt;br&gt;
      expression4,&lt;br&gt;
      expression5&lt;br&gt;
   expression6&lt;/p&gt;
&lt;p&gt;to this:&lt;/p&gt;
&lt;p&gt;   expression1,&lt;br&gt;
   try&lt;br&gt;
      foo.validate(),&lt;br&gt;
      expression2,&lt;br&gt;
      expression3&lt;br&gt;
   catch(&amp;hellip;)&lt;br&gt;
      expression4,&lt;br&gt;
      expression5&lt;br&gt;
   expression6&lt;/p&gt;
&lt;p&gt;The flow of the second program is more confusing in this case. It is not readily apparent that the conditional dispatch actually is based on just the first line in the try block, and that the rest of the expressions are only there for the purpose of being run when foo validates. The if blocks make this point blatantly clear.&lt;/p&gt;
&lt;p&gt;I prefer assertions for the same linear flow reasons. When I want to sanity check for a value, it is cleaner to do this:&lt;/p&gt;
&lt;p&gt;   assert conditional1&lt;/p&gt;
&lt;p&gt;rather than this:&lt;/p&gt;
&lt;p&gt;   if (conditional1)&lt;br&gt;
      throw BadException&lt;/p&gt;
&lt;p&gt;This is on top of the semantic meaning of assertion which tells other programmers that &amp;ldquo;no, this really shouldn&amp;rsquo;t happen, but I&amp;rsquo;m just making sure.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;And now you know all you need to know when choosing whether to use an exception, a status code, or an assertion. Next in my series on exceptional code I shall dive into exceptions being part of a method&amp;rsquo;s signature.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related posts in this series:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/exceptional-pro/&#34;&gt;Exceptional Programming&lt;/a&gt; - Introduction to exception handling best practices&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/exceptions-are/&#34;&gt;Exceptions are part of the Method Signature&lt;/a&gt; - How exceptions form part of your method&amp;rsquo;s contract&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/catching-except/&#34;&gt;Catching Exceptions&lt;/a&gt; - Comprehensive guide to error handling techniques&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Exceptional Programming</title>
      <link>http://localhost:1313/posts/exceptional-pro/</link>
      <pubDate>Sun, 13 Apr 2008 20:14:29 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/exceptional-pro/</guid>
      <description>&lt;p&gt;No battle plan ever survives contact with the enemy.&lt;br&gt;
&amp;ndash; Helmuth von Moltke the Elder&lt;/p&gt;
&lt;p&gt;No discussion of handling exceptions in programming should begin without quoting the great Prussian &lt;a href=&#34;http://en.wikipedia.org/wiki/Helmuth_von_Moltke_the_Elder&#34;&gt;Generalfeldmarschall Helmuth Karl Bernhard Graf von Moltke&lt;/a&gt;. In software development, your programs are the battle plans and inputs are the enemy. Even bad programmers can write a program that works when everything goes as expected. Good programmers write programs that gracefully handle all plausible situations.&lt;/p&gt;
&lt;p&gt;I will imbue onto you the knowledge necessary to write such graceful programs. As part of a multi-part series, I will go into all the wonderful things that good developers should know when dealing with exceptional cases. I&amp;rsquo;m assuming that anyone reading this already understands the technical aspects of exceptions. If you don&amp;rsquo;t and you are programming in Java, you can start out by reading &lt;a href=&#34;http://java.sun.com/docs/books/tutorial/essential/exceptions/index.html&#34;&gt;Sun&amp;rsquo;s tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First up, I will go into the differences between exceptions, status codes, and assertions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related posts in this series:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/exceptions-vs-s/&#34;&gt;Exceptions vs. Status Codes vs. Assertions&lt;/a&gt; - Understanding the differences between error handling techniques&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/exceptions-are/&#34;&gt;Exceptions are part of the Method Signature&lt;/a&gt; - How exceptions form part of your method&amp;rsquo;s contract&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/posts/catching-except/&#34;&gt;Catching Exceptions&lt;/a&gt; - Comprehensive guide to error handling techniques&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
