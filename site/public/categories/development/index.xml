<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on BonnyCode</title>
    <link>http://localhost:1313/categories/development/</link>
    <description>Recent content in Development on BonnyCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 28 Sep 2013 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Throwaway Code: A Love Story</title>
      <link>http://localhost:1313/posts/throwaway-code-a-love-story/</link>
      <pubDate>Sat, 28 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/throwaway-code-a-love-story/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Throwaway Code&lt;/strong&gt;&lt;br&gt;
THrōəwā kōd&lt;br&gt;
&lt;em&gt;noun&lt;/em&gt; - Code that is written to launch a feature early, but will later be deleted either due to a future feature or a new process.&lt;br&gt;
&lt;em&gt;The BonnyCode Dictionary of Software Terms&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Not every love story is the same. There is the classic story of love at first sight. The love that feels destined and obvious from the very first moment. Source control was that way for me. I didn&amp;rsquo;t always use source control (gasp!), but I never went back once I did.&lt;/p&gt;
&lt;p&gt;I didn&amp;rsquo;t always love throwaway code. I may have occasionally flirted with throwaway code&amp;rsquo;s prettier cousin, the prototype, but I wouldn&amp;rsquo;t be caught dead with throwaway code. Today though? Throwaway code is one of the most powerful tools for a software developer. If I was on a desert island, and I was for some reason forced to do software development on that island, and for some reason I was limited in what abstract concepts I could take with me to that desert island, I would take throwaway code. And I would take long, romantic, moonlit walks on that beautiful desert island beach with throwaway code.&lt;/p&gt;
&lt;p&gt;How did I go from hating throwaway code to being soul mates? Throwaway code is so important because it is what makes iterative software development possible. The reason throwaway code is unappreciated, even in this age of Agile development, is because people don&amp;rsquo;t understand what it means to develop iteratively. Scientists have classified 3 stages of iterative development:&lt;/p&gt;
&lt;h2 id=&#34;stage-1-pretending&#34;&gt;Stage 1: Pretending&lt;/h2&gt;
&lt;p&gt;When most teams first try scrum (aka Agile with training wheels), they take a surface level approach to the process. They pick some short iteration cycle, 1-week, 2-weeks or a month. Strangely, nobody ever picks 3-weeks. Anyways, they then run the same process they always did, they just associated the work with whatever iteration is in flight. For example, a sprint planning meeting will go something like this:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;What are you working on this sprint?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;We are first working on testing the new Bear Translator functionality developed in the last sprint. We are then finishing up coding on the Bear Imagine functionality that we started two sprints ago but got delayed.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;In the pretend stage of iterative development, iterations are treated more like time labels for when work occurred and a way of determining how often to have meetings to discuss what to work on. The work itself isn&amp;rsquo;t driven by the iterations though.&lt;/p&gt;
&lt;h2 id=&#34;stage-2-done-done&#34;&gt;Stage 2: Done Done&lt;/h2&gt;
&lt;p&gt;Teams advance from the pretending phase of iterative development to the done done phase. This phase is characterized by the following exchange occurring several times a sprint:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Is the Bear Translator done?&amp;rdquo;&lt;br&gt;
&amp;ldquo;Yes&amp;rdquo;&lt;br&gt;
&amp;ldquo;Is it done done?&amp;rdquo;&lt;br&gt;
&amp;ldquo;No&amp;rdquo;&lt;/p&gt;
&lt;p&gt;This makes up for the failings of the pretend stage by emphasizing that the goal is to finish work inside of the sprint boundaries. It enforces a good discipline on the team to finish features. There is a heavy emphasis in this stage on time-boxing. Unlike the previous stage, the time-boxed sprint becomes the main driver for how work is broken up and assigned.&lt;/p&gt;
&lt;h2 id=&#34;stage-3-customer-use&#34;&gt;Stage 3: Customer Use&lt;/h2&gt;
&lt;p&gt;The final stage of iterative development moves from the frame of reference away from time-boxes towards minimizing the time before a customer gets value from the software. A typical exchange follows:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;The Bear Translator feature is finished! Let&amp;rsquo;s party!&amp;rdquo;&lt;br&gt;
&amp;ldquo;That&amp;rsquo;s great, how many people have used it?&amp;rdquo;&lt;br&gt;
&amp;ldquo;Nobody, we don&amp;rsquo;t have a UI for interacting with it yet. We&amp;rsquo;ve only deployed the backend work.&amp;rdquo;&lt;br&gt;
&amp;ldquo;Party is over everyone, the feature isn&amp;rsquo;t actually finished.&amp;rdquo;&lt;br&gt;
&amp;lt;collective groan, people throwing red plastic cups at the developer for being lame&amp;gt;&lt;/p&gt;
&lt;p&gt;This stage emphasizes building the minimal customer-valuable feature and then iteratively building on that to provide more value. The training wheels are off at this point and the sprint time-boxes are no longer necessary. The discipline learned from progressing through Stage 2 is useful at this point though because the emphasis needs to remain on finishing features.&lt;/p&gt;
&lt;h2 id=&#34;the-secret-of-iterative-development&#34;&gt;The Secret of Iterative Development&lt;/h2&gt;
&lt;p&gt;Most software teams are stuck somewhere between stages 1 and 2 of iterative development. Throwaway code appears as waste in these first two stages. If total value of a feature is measured as a typical manufacturing formula (Total Value = Manufacturing Rate * Value of Good), then any code that is thrown away is a loss on the expected total value. The secret to iterative development comes down to one concept. And it has little to do with the time-value of money or economic order quantities.&lt;/p&gt;
&lt;p&gt;The reason why iterative development is important is because &lt;strong&gt;software requirements aren&amp;rsquo;t known until the software is used by customers.&lt;/strong&gt; I no longer say this phrase around experienced developers because it provokes an uncontrollable reaction to tell me war-stories about just how true it is. The period between software development and customer use is when software can go off track. The smaller you make the cycle between the two, the more likely you are developing the right thing. These constant checkpoints make sure you are pointed in the right direction.&lt;/p&gt;
&lt;p&gt;To get an intuitive sense of just how critical this is, you can try the following experiment at home. Get in your car (a bike will also work) and drive to a part of town you&amp;rsquo;ve been to before.&lt;/p&gt;
&lt;p&gt;First, to simulate non-iterative software development: while driving, close your eyes for 1 minute and open them for minute, then close them for a minute, etc. You&amp;rsquo;ll find that when your eyes were closed, you probably ran into a building, ran stop lights, endangered many lives including your own.&lt;/p&gt;
&lt;p&gt;Second, if you are still conscious, simulate iterative software development: while driving, close your eyes for 1 second, then open them for 1 second, etc. Despite your eyes being closed for the same amount of time as in the first example, you likely never ran off the road and, if you did hit someone, you probably meant to do it.&lt;/p&gt;
&lt;p&gt;This is the difference between iterative development and non-iterative development. You know that you are on track because you are getting constant feedback. And you are getting that feedback where it matters, from the people that will use your software. Iterative development is so critical to staying on track that I will write copious amount of throwaway code to make iterations short. The ironic thing is, the people that avoid throwaway code end up writing the most in the end. They just do it unintentionally because they write large amounts of code that never gets used because their feature was off-track from the beginning.&lt;/p&gt;
&lt;p&gt;I love writing throwaway code because it is this beautiful launch vehicle to get the code I want to last out there and used immediately. When I actively make the decision to write it, I know there is a good chance I&amp;rsquo;m on the right track.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>In Defense of Duplicated Code</title>
      <link>http://localhost:1313/posts/in-defense-of-duplicated-code/</link>
      <pubDate>Sun, 30 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/in-defense-of-duplicated-code/</guid>
      <description>&lt;p&gt;One of the first principles you will hear from anyone hoping to impart software development wisdom on young disciples is DRY. Don&amp;rsquo;t Repeat Yourself. If software best practices all lived in a little nation, the Honourable Commonwealth of Softwaria, its king would be DRY. A good king he was too.&lt;/p&gt;
&lt;p&gt;Since ages long since past, DRY has helped to keep javascripters from copy and pasting themselves into another rathole. At first, King DRY used methods to remove duplicate code. Formatting integers to currency a bajillion different places? No problem make a method to do the formating. The code is better because it is more readable (formatAsCurrency) and if you ever need to change or extend the logic you can do so in one place. Huzzah!&lt;/p&gt;
&lt;p&gt;Over the years, DRY took on further battles for the people of Softwaria. In the Thirty Year War against Visual Basic programmers, DRY brought forth the mighty powers of composition. Now large segments of functionality and data, not just individual methods, could be transported and duplicated to be used anywhere. A method to format an integer into currency? How about a currency class instead that can not only format itself to a string but also do any other logic you want to on currency all bundled nicely in a little package. Besides removing duplicate code, composition also provided encapsulation, higher cohesion and lowered coupling (the bad kind not the good kind!).&lt;/p&gt;
&lt;h2 id=&#34;the-corruption-of-power&#34;&gt;The Corruption of Power&lt;/h2&gt;
&lt;p&gt;As Lord Action once said though, power tends to corrupt, and absolute power corrupts absolutely. For in his zealous fervor to ban any duplicate code or logic he was tempted into delving into powerful and dark arts. DRY called upon his most powerful sorcerers who gave him the power of implementation inheritance. Yes he did eke out yet more removal of duplicated code. But in the process he sacrificed most of the benefits that encapsulation had provided.&lt;/p&gt;
&lt;p&gt;Yet more dissidents were found in the kingdom of Softwaria though and DRY delved into yet darker arts to combat them. This time he tapped into the power of reflection. With this power he could make mountains move (even if they were declared private!). Giddy with power, the king annihilated the duplicated code. Yes he had to sacrifice readability, but it seemed a small price to pay to eliminate those treasonous and heretical duplicate code bastards.&lt;/p&gt;
&lt;h2 id=&#34;the-final-corruption&#34;&gt;The Final Corruption&lt;/h2&gt;
&lt;p&gt;Finally, in the dark recesses of the kingdom, DRY found the last remaining resistance movements of duplicated code. They didn&amp;rsquo;t bother people much, they were largely just simple workers tilling away at their small plot of program. By this time the good king had become fanatical though. ALL DUPLICATED CODE MUST DIE! He called on his sorcerers one final time and asked for the power to remove the remaining resistance. He offered anything in his kingdom just for this one final grant of power. And the sorcerers delivered for they offered the power of metaprogramming.&lt;/p&gt;
&lt;p&gt;Now the King was no longer bound by the traditional physics of the land, instead he could reshape it in whatever likeness he desired. In the land of Java the king created code generators that created wide areas of forbidden code, code never to be touched or even looked at. XML spread like a disease, soon used to store the most important program logic. In the land of Ruby, programs created other programs and whole new languages sprang forth from nowhere to solve the most trivial of problems. Ruby on Rails came riding high with instant magical scaffolds. And the last of the duplicated code died&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;the-kingdoms-end&#34;&gt;The Kingdom&amp;rsquo;s End&lt;/h2&gt;
&lt;p&gt;The king was satisfied with himself for he had finally fulfilled his ultimate goal. Old King DRY stepped out to view his wondrous kingdom and no longer recognized what he saw. It was incomprehensible. Nothing made sense anymore, nothing was predictable and nothing worked as it seemed. Nobody, not even King DRY who created this world, understood it anymore. The sorcerers laughed knowing the land was now ruled by magic and the good king wept.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Persistence: The long lost virtue of fixing a bug</title>
      <link>http://localhost:1313/posts/persistence-the-long-lost-virtue/</link>
      <pubDate>Sun, 23 Nov 2008 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/persistence-the-long-lost-virtue/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;The heights by great men reached and kept&lt;br&gt;
Were not attained by sudden flight,&lt;br&gt;
But they, while their companions slept,&lt;br&gt;
Were toiling upward in the night.&lt;br&gt;
&lt;em&gt;&amp;ndash; Henry Wadsworth Longfellow&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You&amp;rsquo;re working on a difficult bug. A strange log message showing that your program fails every once in a while. Looking at your watch you see you&amp;rsquo;ve already been working on it for half an hour. You put the bug back on the router thinking to yourself maybe someone else will have better luck. And then a man from the future appears behind you&amp;hellip; oh never mind I won&amp;rsquo;t subject you to that torture again.&lt;/p&gt;
&lt;p&gt;If you are like most software developers you&amp;rsquo;ve been in the situation above. Maybe instead you mark the bug as &amp;ldquo;Cannot Reproduce&amp;rdquo; or you instead assign it to your resident expert. Regardless of the means you use to escape from fixing the bug, you are dodging an important opportunity. This is normally when I start hearing the excuses. The bug is too hard. Someone else could fix it sooo much faster. There are too many bugs to waste time on just one. Forget the excuses, it is worth it both to you and the product you are creating. Oh let me count the ways.&lt;/p&gt;
&lt;h2 id=&#34;why-persistence-pays-off&#34;&gt;Why Persistence Pays Off&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. You are actually learning something deep about the technology you work with.&lt;/strong&gt; Sure the first time you are learning something you are slow. Really slow. But you are learning. You are dissecting the technology and learning how it really works. In the future with this deep knowledge you will be able to quickly solve problems. You are increasing your skill set as a developer which is good for the company you work for now and for your future marketability later.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. You are wasting the time you spent getting up to speed on the problem.&lt;/strong&gt; You pick up the bug, spend 30 minutes and then put it back on the router. The next person picks it up, spends 30 minutes and then puts it back on the router. yadda yadda. This is a huge waste of everyone&amp;rsquo;s time. The same if you mark it as cannot reproduce, but instead you are wasting the time of the customer or testers and then more developers later when they bring up the bug again in a new form.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Not only is the bug noise on the router, it is also noise in the logs.&lt;/strong&gt; It is a common tradition in too many software shops to have their set of ignorable errors that just seem to happen and nobody really knows why but they seem fairly harmless so nobody fixes them. Not to say people didn&amp;rsquo;t try, I&amp;rsquo;m sure at least 5 people spent their 30 minutes on trying to fix it. Noise in the logs is not a good thing though. It could actually be a problem that will only manifest itself at an inopportune time. Even if it is genuinely harmless, it is still one more thing for humans to mentally parse and ignore and distracts away from seeing the real bugs.&lt;/p&gt;
&lt;h2 id=&#34;fix-the-root-cause-not-the-symptoms&#34;&gt;Fix the Root Cause, Not the Symptoms&lt;/h2&gt;
&lt;p&gt;At this point you maybe be telling yourself &amp;ldquo;Great I&amp;rsquo;m going to fix all the bugs&amp;rdquo;. Look a null pointer exception, all I need is a little if statement null check and I&amp;rsquo;m good.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hold On!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Resist the urge to cut off the investigation early. Fixing the symptoms of a bug is NOT fixing the bug. Why is that variable null? Is it supposed to be nullable even? You must find the root cause even if it takes you 10 or 20 times longer. Treat the bug as if it was a memory corruption bug. You can try treating each of the various symptoms of the memory corruption and varied they will be. Or you can hit that one spot where it is actually occurring and fix it for good.&lt;/p&gt;
&lt;p&gt;The trade off is really this, you can either spend 2 days going deep, really understanding how something works and understanding the core of the issue, or you can spend the next month making tiny one off fixes that treat just the symptoms. In the end sticking with it and finding the real problem is 95% of the time more cost effective than just treating the symptoms. And speaking from experience, it is much more gratifying as well.&lt;/p&gt;
&lt;h2 id=&#34;persistence-vs-stupidity&#34;&gt;Persistence vs. Stupidity&lt;/h2&gt;
&lt;p&gt;Persistence does not equal stupidity. Banging your head against a problem and making no progress is not persistence anymore than running on a treadmill is a form of transportation. Well&amp;hellip; not normally at least. I see lack of persistence as the biggest thing that holds people back, but many people don&amp;rsquo;t even know how to go about fixing the hard problems. It is a skill and I could go on about divide and conquer, how to actually use google and a million other tidbits. As an honest to goodness skill though, my best advice is to pair up with the best, most knowledgeable bug fixer you know.&lt;/p&gt;
&lt;p&gt;Who is the developer that ends up actually fixing the really hard problems when they come up? Tackle a really hard problem with them. When you get stuck on a really hard bug, don&amp;rsquo;t give up, but do ask for advice explaining your progress so far. Don&amp;rsquo;t ask them to do the work for you, but do ask for pointers on where to look next. Often times you&amp;rsquo;ll find the act of just explaining what you&amp;rsquo;ve discovered will lead you to the solution on your own.&lt;/p&gt;
&lt;p&gt;Remember this. Any script kiddie can copy and paste some code, tweak some values and get a system they barely understand to kinda work. If you want to distinguish yourself as a software developer, work to truly understand the system you are building, don&amp;rsquo;t shy away from the difficult problems and don&amp;rsquo;t stop until you really know what is going on.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Strictly Need to Know</title>
      <link>http://localhost:1313/posts/strictly-need-to-know/</link>
      <pubDate>Sun, 18 May 2008 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/strictly-need-to-know/</guid>
      <description>&lt;p&gt;One of the bedrock principles in software engineering is information hiding. The traditional idea behind information hiding is imagined in the context of a group of software developers. Each of these software developers is working on their module that will use and be used by the modules made by other software developers. Given that software development is messy, we want to be able to make changes/fixes/upgrades to our module even after our module is in use by other modules. A module developer thus applies the principle of information hiding to separate the more stable interface of their module from the less stable implementation details. Other modules can only see the interface and not the implementation details, which gives the module developer the freedom to change the implementation details after it has begun to be used by other module developers.&lt;/p&gt;
&lt;p&gt;If this was still 1972 then the discussion could end here and we could all go back to writing that payroll program on the company&amp;rsquo;s UNIVAC 1108 like these two developers.&lt;/p&gt;
&lt;p&gt;Today, in the year 2008, state of the art software development looks more like these two developers who are pair programming a new facebook app.&lt;/p&gt;
&lt;p&gt;One of the first things you should notice is that today&amp;rsquo;s developers smile a lot more than developers from the 70s. This is because programming in the 70s was boring and lonely. Everybody (not just software developers) was all secretive and into hoarding information. Government agencies had strict need to know policies which prevented information from being shared and real intelligence from being synthesized. It is no surprise that this environment spawned a software methodology like waterfall based on the premise of cleanly separated departments with well established hand off points and restricted communication.&lt;/p&gt;
&lt;h2 id=&#34;lessons-from-intelligence-failures&#34;&gt;Lessons from Intelligence Failures&lt;/h2&gt;
&lt;p&gt;The failings of this approach are evident across the board. The 9/11 Report offers a clear description of the problem:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In each of our examples, no one was firmly in charge of managing the case and able to draw relevant intelligence from anywhere in the government, assign responsibilities across the agencies (foreign or domestic), track progress, and quickly bring obstacles up to the level where they could be resolved. Responsibility and accountability were diffuse.&lt;/p&gt;
&lt;p&gt;The agencies cooperated, some of the time. But even such cooperation as there was is not the same thing as joint action. &lt;strong&gt;When agencies cooperate, one defines the problem and seeks help with it. When they act jointly, the problem and options for action are defined differently from the start. Individuals from different backgrounds come together in analyzing a case and planning how to manage it.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;p&gt;In the 9/11 story, for example, we sometimes see examples of information that could be accessed—like the undistributed NSA information that would have helped identify Nawaf al Hazmi in January 2000. But someone had to ask for it. In that case, no one did. Or, as in the episodes we describe in chapter 8, the information is distributed, but in a compartmented channel. Or the information is available, and someone does ask, but it cannot be shared. &lt;strong&gt;What all these stories have in common is a system that requires a demonstrated &amp;ldquo;need to know&amp;rdquo; before sharing. This approach assumes it is possible to know, in advance, who will need to use the information.&lt;/strong&gt; Such a system implicitly assumes that the risk of inadvertent disclosure outweighs the benefits of wider sharing. Those Cold War assumptions are no longer appropriate. The culture of agencies feeling they own the information they gathered at taxpayer expense must be replaced by a culture in which the agencies instead feel they have a duty to the information—to repay the taxpayers&amp;rsquo; investment by making that information available.&lt;/p&gt;
&lt;p&gt;Each intelligence agency has its own security practices, outgrowths of the Cold War. We certainly understand the reason for these practices. Counterintelligence concerns are still real, even if the old Soviet enemy has been replaced by other spies.&lt;/p&gt;
&lt;p&gt;But the security concerns need to be weighed against the costs. Current security requirements nurture overclassification and excessive compartmentation of information among agencies. Each agency&amp;rsquo;s incentive structure opposes sharing, with risks (criminal, civil, and internal administrative sanctions) but few rewards for sharing information. No one has to pay the long-term costs of overclassifying information, though these costs—even in literal financial terms—are substantial. There are no punishments for not sharing information. &lt;strong&gt;Agencies uphold a &amp;ldquo;need-to-know&amp;rdquo; culture of information protection rather than promoting a &amp;ldquo;need-to-share&amp;rdquo; culture of integration.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;ndash; The 9/11 Commission Report&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;from-need-to-know-to-need-to-share&#34;&gt;From Need-to-Know to Need-to-Share&lt;/h2&gt;
&lt;p&gt;Modern agile programming techniques no longer have us living in a world of solitary software developers building their solely owned modules. Instead code is collectively owned by the team and there is no longer an &amp;ldquo;other&amp;rdquo; on the team to hide information from. Change is not feared because anyone on the team can make changes anywhere in the code. Changes are made safe through constant communication, a strict adherence to simplicity and a profound emphasis on readability.&lt;/p&gt;
&lt;p&gt;In this way the principle of information hiding is replaced by the principle of readability, changing the software team from a &amp;ldquo;need-to-know&amp;rdquo; culture to a &amp;ldquo;need-to-share&amp;rdquo; culture. Encapsulation and separation of concerns are no longer important because of information hiding but only when they make programs more readable. If the US government is willing to acknowledge the failures of information hiding despite the very real threat of espionage from foreign governments, what reasoning do you still have for promoting information hiding to protect yourself from your coworker at the next desk?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
