/**
 * Berkson's Paradox Visualization
 * Shows inverse correlation due to selection bias
 */

export function initBerksonParadox(config) {
    const dagCanvas = document.getElementById(config.dagCanvasId);
    const fullCanvas = document.getElementById(config.fullCanvasId);
    const selectedCanvas = document.getElementById(config.selectedCanvasId);
    const stepBtn = document.getElementById(config.stepId);
    const runBtn = document.getElementById(config.runId);
    const resetBtn = document.getElementById(config.resetId);
    const thresholdSlider = document.getElementById(config.thresholdId);
    const thresholdValue = document.getElementById(config.thresholdValueId);

    if (!dagCanvas || !fullCanvas || !selectedCanvas) return;

    const dagCtx = dagCanvas.getContext('2d');
    const fullCtx = fullCanvas.getContext('2d');
    const selectedCtx = selectedCanvas.getContext('2d');

    let data = [];
    let threshold = 100;
    let running = false;
    let animationId = null;

    function reset() {
        data = [];
        running = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
        runBtn.textContent = 'Run';
        drawDAG();
        drawScatterplots();
    }

    function step() {
        // Add 5 new random data points
        for (let i = 0; i < 5; i++) {
            const skill = Math.random() * 100;
            const charisma = Math.random() * 100;
            const selected = (skill + charisma) > threshold;
            data.push({ skill, charisma, selected });
        }

        // Keep last 200 points
        if (data.length > 200) {
            data = data.slice(-200);
        }

        drawScatterplots();
    }

    function linearRegression(points) {
        const n = points.length;
        if (n === 0) return { slope: 0, intercept: 0 };

        let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
        for (const p of points) {
            sumX += p.skill;
            sumY += p.charisma;
            sumXY += p.skill * p.charisma;
            sumXX += p.skill * p.skill;
        }

        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        return { slope, intercept };
    }

    function getColors() {
        const isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        return {
            bg: isDark ? '#1d2021' : '#fbf1c7',
            fg: isDark ? '#ebdbb2' : '#3c3836',
            fg2: isDark ? '#a89984' : '#7c6f64',
            rejected: isDark ? '#504945' : '#bdae93',
            selected: isDark ? '#b8bb26' : '#79740e',
            threshold: isDark ? '#d79921' : '#d65d0e',
            allLine: isDark ? '#458588' : '#076678',
            selectedLine: isDark ? '#cc241d' : '#9d0006',
            node: isDark ? '#458588' : '#076678',
            edge: isDark ? '#a89984' : '#7c6f64'
        };
    }

    function setupCanvas(canvas, aspectRatio) {
        const dpr = window.devicePixelRatio || 1;
        const container = canvas.parentElement;
        const displayWidth = container.clientWidth;
        const displayHeight = Math.round(displayWidth / aspectRatio);

        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';

        const ctx = canvas.getContext('2d');
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        return { width: displayWidth, height: displayHeight };
    }

    function drawDAG() {
        const dims = setupCanvas(dagCanvas, 3);
        const { width, height } = dims;
        const colors = getColors();

        dagCtx.clearRect(0, 0, width, height);
        dagCtx.fillStyle = colors.bg;
        dagCtx.fillRect(0, 0, width, height);

        const nodeRadius = 30;
        const nodes = {
            skill: { x: width * 0.25, y: height * 0.5, label: 'Skill' },
            charisma: { x: width * 0.5, y: height * 0.5, label: 'Charisma' },
            selection: { x: width * 0.75, y: height * 0.5, label: 'Selected' }
        };

        // Draw edges (arrows)
        dagCtx.strokeStyle = colors.edge;
        dagCtx.fillStyle = colors.edge;
        dagCtx.lineWidth = 2;

        // Skill -> Selection
        drawArrow(dagCtx, nodes.skill.x + nodeRadius, nodes.skill.y,
                  nodes.selection.x - nodeRadius, nodes.selection.y);

        // Charisma -> Selection
        drawArrow(dagCtx, nodes.charisma.x + nodeRadius, nodes.charisma.y,
                  nodes.selection.x - nodeRadius, nodes.selection.y);

        // Draw nodes
        for (const key in nodes) {
            const node = nodes[key];
            const isCollider = key === 'selection';

            dagCtx.fillStyle = isCollider ? colors.threshold : colors.node;
            dagCtx.beginPath();
            dagCtx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
            dagCtx.fill();

            dagCtx.fillStyle = colors.bg;
            dagCtx.font = '12px sans-serif';
            dagCtx.textAlign = 'center';
            dagCtx.textBaseline = 'middle';
            dagCtx.fillText(node.label, node.x, node.y);
        }

        // Add explanation text
        dagCtx.fillStyle = colors.fg;
        dagCtx.font = '11px sans-serif';
        dagCtx.textAlign = 'center';
        dagCtx.fillText('Conditioning on a collider creates spurious correlation', width / 2, height - 15);
    }

    function drawArrow(ctx, x1, y1, x2, y2) {
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const headLength = 10;

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6),
                   y2 - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6),
                   y2 - headLength * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();
    }

    function draw() {
        const colors = getColors();
        const padding = { top: 30, right: 20, bottom: 50, left: 60 };
        const plotW = width - padding.left - padding.right;
        const plotH = height - padding.top - padding.bottom;

        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = colors.bg;
        ctx.fillRect(0, 0, width, height);

        // Scales
        const maxVal = 100;
        const scaleX = (x) => padding.left + (x / maxVal) * plotW;
        const scaleY = (y) => height - padding.bottom - (y / maxVal) * plotH;

        // Draw selection threshold line (skill + charisma = 100)
        ctx.strokeStyle = colors.threshold;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(scaleX(0), scaleY(100));
        ctx.lineTo(scaleX(100), scaleY(0));
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw axes
        ctx.strokeStyle = colors.fg2;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding.left, padding.top);
        ctx.lineTo(padding.left, height - padding.bottom);
        ctx.lineTo(width - padding.right, height - padding.bottom);
        ctx.stroke();

        // X-axis labels
        ctx.fillStyle = colors.fg;
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let i = 0; i <= 5; i++) {
            const val = (maxVal / 5) * i;
            const x = scaleX(val);
            ctx.fillText(val, x, height - padding.bottom + 5);
        }

        // Y-axis labels
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i <= 5; i++) {
            const val = (maxVal / 5) * i;
            const y = scaleY(val);
            ctx.fillText(val, padding.left - 5, y);
        }

        // Axis titles
        ctx.fillStyle = colors.fg;
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('Skill', width / 2, height - 20);

        ctx.save();
        ctx.translate(15, height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('Charisma', 0, 0);
        ctx.restore();

        // Draw regression line for all data
        ctx.strokeStyle = colors.allLine;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        const y1All = allRegression.intercept;
        const y2All = allRegression.slope * 100 + allRegression.intercept;
        ctx.moveTo(scaleX(0), scaleY(y1All));
        ctx.lineTo(scaleX(100), scaleY(y2All));
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Draw regression line for selected data
        ctx.strokeStyle = colors.selectedLine;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const y1Sel = selectedRegression.intercept;
        const y2Sel = selectedRegression.slope * 100 + selectedRegression.intercept;
        ctx.moveTo(scaleX(0), scaleY(y1Sel));
        ctx.lineTo(scaleX(100), scaleY(y2Sel));
        ctx.stroke();

        // Draw data points (rejected first, then selected on top)
        for (const d of data) {
            if (!d.selected) {
                ctx.fillStyle = colors.rejected;
                ctx.globalAlpha = 0.3;
                const px = scaleX(d.skill);
                const py = scaleY(d.charisma);
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1;

        for (const d of data) {
            if (d.selected) {
                ctx.fillStyle = colors.selected;
                const px = scaleX(d.skill);
                const py = scaleY(d.charisma);
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Legend
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'left';
        const legendX = padding.left + 10;
        const legendY = padding.top + 10;

        ctx.fillStyle = colors.rejected;
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(legendX + 5, legendY, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.fillStyle = colors.fg;
        ctx.fillText('Rejected', legendX + 15, legendY + 4);

        ctx.fillStyle = colors.selected;
        ctx.beginPath();
        ctx.arc(legendX + 5, legendY + 20, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = colors.fg;
        ctx.fillText('Hired (skill + charisma > 100)', legendX + 15, legendY + 24);

        ctx.strokeStyle = colors.selectedLine;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(legendX, legendY + 40);
        ctx.lineTo(legendX + 30, legendY + 40);
        ctx.stroke();
        ctx.fillStyle = colors.fg;
        ctx.fillText('Trend in hired (negative!)', legendX + 35, legendY + 44);
    }

    window.addEventListener('resize', resize);
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', draw);

    resize();
}
